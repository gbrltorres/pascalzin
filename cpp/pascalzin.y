/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the pascalzin_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE pascalzin__scan_string(const char *str, yyscan_t scanner);
extern void pascalzin__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void pascalzin_lex_destroy(yyscan_t scanner);
extern char* pascalzin_get_text(yyscan_t scanner);

extern yyscan_t pascalzin__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Entry* entry_;
  BlocoDefinicoes* blocodefinicoes_;
  BlocoFuncaoEProc* blocofuncaoeproc_;
  BlocoConstante* blococonstante_;
  RegraBlocoConstante* regrablococonstante_;
  BlocoTipo* blocotipo_;
  RegraBlocoTipo* regrablocotipo_;
  BlocoVar* blocovar_;
  RegraBlocoVar* regrablocovar_;
  BlocoComando* blococomando_;
  RegraComando* regracomando_;
  Comando* comando_;
  Atribuicao* atribuicao_;
  SubEscrito* subescrito_;
  RegraTipo* regratipo_;
  TipoPrimitivo* tipoprimitivo_;
  Valor* valor_;
  TipoDerivado* tipoderivado_;
  Ponteiro* ponteiro_;
  Vetor* vetor_;
  If* if_;
  While* while_;
  For* for_;
  Goto* goto_;
  Rotulo* rotulo_;
  Struct* struct_;
  DefinicaoCampoStruct* definicaocampostruct_;
  AtribuicaoStruct* atribuicaostruct_;
  OperadorRelacional* operadorrelacional_;
  OperadorLogico* operadorlogico_;
  Negacao* negacao_;
  OperadorAritmetico* operadoraritmetico_;
  Case* case_;
  RegraSeletor* regraseletor_;
  Seletor* seletor_;
  ChamadaFuncaoEProc* chamadafuncaoeproc_;
  ListaIdent* listaident_;
  Funcao* funcao_;
  Procedimento* procedimento_;
  ExpressaoAritmetica* expressaoaritmetica_;
  Operando* operando_;
  RegraAritmetica* regraaritmetica_;
  ExpressaoRelacional* expressaorelacional_;
  RegraRelacional* regrarelacional_;
  ExpressaoLogica* expressaologica_;
  RegraLogico* regralogico_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, pascalzin_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG             /* ! */
%token          _DAMP             /* && */
%token          _SYMB_18          /* &| */
%token          _LPAREN           /* ( */
%token          _RPAREN           /* ) */
%token          _STAR             /* * */
%token          _PLUS             /* + */
%token          _COMMA            /* , */
%token          _MINUS            /* - */
%token          _DOT              /* . */
%token          _DDOT             /* .. */
%token          _SLASH            /* / */
%token          _COLON            /* : */
%token          _COLONEQ          /* := */
%token          _SEMI             /* ; */
%token          _LT               /* < */
%token          _LDARROW          /* <= */
%token          _LTGT             /* <> */
%token          _EQ               /* = */
%token          _GT               /* > */
%token          _GTEQ             /* >= */
%token          _LBRACK           /* [ */
%token          _RBRACK           /* ] */
%token          _CARET            /* ^ */
%token          _KW_ate           /* ate */
%token          _KW_caso          /* caso */
%token          _KW_char          /* char */
%token          _KW_const         /* const */
%token          _KW_de            /* de */
%token          _KW_enquanto      /* enquanto */
%token          _KW_entao         /* entao */
%token          _KW_faca          /* faca */
%token          _KW_falso         /* falso */
%token          _KW_fim           /* fim */
%token          _KW_funcao        /* funcao */
%token          _KW_inicio        /* inicio */
%token          _KW_int           /* int */
%token          _KW_para          /* para */
%token          _KW_procedimento  /* procedimento */
%token          _KW_programa      /* programa */
%token          _KW_real          /* real */
%token          _KW_registro      /* registro */
%token          _KW_se            /* se */
%token          _KW_senao         /* senao */
%token          _KW_sovai         /* sovai */
%token          _KW_tipo          /* tipo */
%token          _KW_var           /* var */
%token          _KW_verdadeiro    /* verdadeiro */
%token          _KW_vetor         /* vetor */
%token          _DBAR             /* || */
%token<_string> _STRING_
%token<_char>   _CHAR_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <entry_> Entry
%type <blocodefinicoes_> BlocoDefinicoes
%type <blocofuncaoeproc_> BlocoFuncaoEProc
%type <blococonstante_> BlocoConstante
%type <regrablococonstante_> RegraBlocoConstante
%type <blocotipo_> BlocoTipo
%type <regrablocotipo_> RegraBlocoTipo
%type <blocovar_> BlocoVar
%type <regrablocovar_> RegraBlocoVar
%type <blococomando_> BlocoComando
%type <regracomando_> RegraComando
%type <comando_> Comando
%type <atribuicao_> Atribuicao
%type <subescrito_> SubEscrito
%type <regratipo_> RegraTipo
%type <tipoprimitivo_> TipoPrimitivo
%type <valor_> Valor
%type <tipoderivado_> TipoDerivado
%type <ponteiro_> Ponteiro
%type <vetor_> Vetor
%type <if_> If
%type <while_> While
%type <for_> For
%type <goto_> Goto
%type <rotulo_> Rotulo
%type <struct_> Struct
%type <definicaocampostruct_> DefinicaoCampoStruct
%type <atribuicaostruct_> AtribuicaoStruct
%type <operadorrelacional_> OperadorRelacional
%type <operadorlogico_> OperadorLogico
%type <negacao_> Negacao
%type <operadoraritmetico_> OperadorAritmetico
%type <case_> Case
%type <regraseletor_> RegraSeletor
%type <seletor_> Seletor
%type <chamadafuncaoeproc_> ChamadaFuncaoEProc
%type <listaident_> ListaIdent
%type <funcao_> Funcao
%type <procedimento_> Procedimento
%type <expressaoaritmetica_> ExpressaoAritmetica
%type <operando_> Operando
%type <regraaritmetica_> RegraAritmetica
%type <expressaorelacional_> ExpressaoRelacional
%type <regrarelacional_> RegraRelacional
%type <expressaologica_> ExpressaoLogica
%type <regralogico_> RegraLogico

%start Entry

%%

Entry : _KW_programa _IDENT_ _SEMI BlocoDefinicoes BlocoComando _DOT { $$ = new LEntry($2, $4, $5); result->entry_ = $$; }
;
BlocoDefinicoes : BlocoFuncaoEProc BlocoDefinicoes { $$ = new BlocoDefinicoes1($1, $2); result->blocodefinicoes_ = $$; }
  | BlocoConstante BlocoDefinicoes { $$ = new BlocoDefinicoes2($1, $2); result->blocodefinicoes_ = $$; }
  | BlocoTipo BlocoDefinicoes { $$ = new BlocoDefinicoes3($1, $2); result->blocodefinicoes_ = $$; }
  | BlocoVar BlocoDefinicoes { $$ = new BlocoDefinicoes4($1, $2); result->blocodefinicoes_ = $$; }
  | /* empty */ { $$ = new BlocoDefinicoes_(); result->blocodefinicoes_ = $$; }
;
BlocoFuncaoEProc : Funcao { $$ = new BlocoFuncaoEProcFuncao($1); result->blocofuncaoeproc_ = $$; }
  | Funcao BlocoFuncaoEProc { $$ = new BlocoFuncaoEProc1($1, $2); result->blocofuncaoeproc_ = $$; }
  | Procedimento { $$ = new BlocoFuncaoEProcProcedimento($1); result->blocofuncaoeproc_ = $$; }
  | Procedimento BlocoFuncaoEProc { $$ = new BlocoFuncaoEProc2($1, $2); result->blocofuncaoeproc_ = $$; }
  | /* empty */ { $$ = new BlocoFuncaoEProc_(); result->blocofuncaoeproc_ = $$; }
;
BlocoConstante : _KW_const RegraBlocoConstante { $$ = new BlocoConstante1($2); result->blococonstante_ = $$; }
  | /* empty */ { $$ = new BlocoConstante_(); result->blococonstante_ = $$; }
;
RegraBlocoConstante : _IDENT_ _EQ Valor _SEMI { $$ = new RegraBlocoConstante1($1, $3); result->regrablococonstante_ = $$; }
  | _IDENT_ _EQ Valor _SEMI RegraBlocoConstante { $$ = new RegraBlocoConstante2($1, $3, $5); result->regrablococonstante_ = $$; }
;
BlocoTipo : _KW_tipo RegraBlocoTipo { $$ = new BlocoTipo1($2); result->blocotipo_ = $$; }
  | /* empty */ { $$ = new BlocoTipo_(); result->blocotipo_ = $$; }
;
RegraBlocoTipo : _IDENT_ _EQ RegraTipo _SEMI { $$ = new RegraBlocoTipo1($1, $3); result->regrablocotipo_ = $$; }
  | _IDENT_ _EQ RegraTipo _SEMI RegraBlocoTipo { $$ = new RegraBlocoTipo2($1, $3, $5); result->regrablocotipo_ = $$; }
;
BlocoVar : _KW_var RegraBlocoVar { $$ = new BlocoVar1($2); result->blocovar_ = $$; }
  | /* empty */ { $$ = new BlocoVar_(); result->blocovar_ = $$; }
;
RegraBlocoVar : _IDENT_ _COLON RegraTipo _SEMI { $$ = new RegraBlocoVar1($1, $3); result->regrablocovar_ = $$; }
  | _IDENT_ _COLON RegraTipo _SEMI RegraBlocoVar { $$ = new RegraBlocoVar2($1, $3, $5); result->regrablocovar_ = $$; }
  | ListaIdent _COLON RegraTipo _SEMI { $$ = new RegraBlocoVar3($1, $3); result->regrablocovar_ = $$; }
  | ListaIdent _COLON RegraTipo _SEMI RegraBlocoVar { $$ = new RegraBlocoVar4($1, $3, $5); result->regrablocovar_ = $$; }
;
BlocoComando : _KW_inicio RegraComando _KW_fim { $$ = new BlocoComando1($2); result->blococomando_ = $$; }
  | /* empty */ { $$ = new BlocoComando_(); result->blococomando_ = $$; }
;
RegraComando : Comando _SEMI { $$ = new RegraComando1($1); result->regracomando_ = $$; }
  | Comando _SEMI RegraComando { $$ = new RegraComando2($1, $3); result->regracomando_ = $$; }
;
Comando : Atribuicao { $$ = new ComandoAtribuicao($1); result->comando_ = $$; }
  | If { $$ = new ComandoIf($1); result->comando_ = $$; }
  | While { $$ = new ComandoWhile($1); result->comando_ = $$; }
  | For { $$ = new ComandoFor($1); result->comando_ = $$; }
  | Goto { $$ = new ComandoGoto($1); result->comando_ = $$; }
  | Case { $$ = new ComandoCase($1); result->comando_ = $$; }
  | ChamadaFuncaoEProc { $$ = new ComandoChamadaFuncaoEProc($1); result->comando_ = $$; }
;
Atribuicao : _IDENT_ _COLONEQ Valor { $$ = new Atribuicao1($1, $3); result->atribuicao_ = $$; }
  | _IDENT_ _COLONEQ ExpressaoAritmetica { $$ = new Atribuicao2($1, $3); result->atribuicao_ = $$; }
  | _IDENT_ _COLONEQ _IDENT_ { $$ = new Atribuicao3($1, $3); result->atribuicao_ = $$; }
  | _IDENT_ _LBRACK SubEscrito _RBRACK _COLONEQ Valor { $$ = new Atribuicao4($1, $3, $6); result->atribuicao_ = $$; }
  | _IDENT_ _CARET _COLONEQ Valor { $$ = new Atribuicao5($1, $4); result->atribuicao_ = $$; }
  | AtribuicaoStruct { $$ = new AtribuicaoAtribuicaoStruct($1); result->atribuicao_ = $$; }
  | _IDENT_ _COLONEQ ChamadaFuncaoEProc { $$ = new Atribuicao6($1, $3); result->atribuicao_ = $$; }
;
SubEscrito : _IDENT_ { $$ = new SubEscritoIdent($1); result->subescrito_ = $$; }
  | _INTEGER_ { $$ = new SubEscritoInteger($1); result->subescrito_ = $$; }
;
RegraTipo : TipoPrimitivo { $$ = new RegraTipoTipoPrimitivo($1); result->regratipo_ = $$; }
  | TipoDerivado { $$ = new RegraTipoTipoDerivado($1); result->regratipo_ = $$; }
  | _IDENT_ { $$ = new RegraTipoIdent($1); result->regratipo_ = $$; }
;
TipoPrimitivo : _KW_int { $$ = new TipoPrimitivo_int(); result->tipoprimitivo_ = $$; }
  | _KW_real { $$ = new TipoPrimitivo_real(); result->tipoprimitivo_ = $$; }
  | _KW_char { $$ = new TipoPrimitivo_char(); result->tipoprimitivo_ = $$; }
;
Valor : _INTEGER_ { $$ = new ValorInteger($1); result->valor_ = $$; }
  | _DOUBLE_ { $$ = new ValorDouble($1); result->valor_ = $$; }
  | _CHAR_ { $$ = new ValorChar($1); result->valor_ = $$; }
  | _STRING_ { $$ = new ValorString($1); result->valor_ = $$; }
;
TipoDerivado : Ponteiro { $$ = new TipoDerivadoPonteiro($1); result->tipoderivado_ = $$; }
  | Vetor { $$ = new TipoDerivadoVetor($1); result->tipoderivado_ = $$; }
  | Struct { $$ = new TipoDerivadoStruct($1); result->tipoderivado_ = $$; }
;
Ponteiro : _CARET TipoPrimitivo { $$ = new Ponteiro1($2); result->ponteiro_ = $$; }
  | _CARET TipoDerivado { $$ = new Ponteiro2($2); result->ponteiro_ = $$; }
;
Vetor : _KW_vetor _LBRACK _INTEGER_ _DDOT _INTEGER_ _RBRACK _KW_de TipoPrimitivo { $$ = new LVetor($3, $5, $8); result->vetor_ = $$; }
;
If : _KW_se _LPAREN ExpressaoLogica _RPAREN _KW_entao BlocoComando { $$ = new If1($3, $6); result->if_ = $$; }
  | _KW_se _LPAREN ExpressaoLogica _RPAREN _KW_entao BlocoComando _KW_senao BlocoComando { $$ = new If2($3, $6, $8); result->if_ = $$; }
;
While : _KW_enquanto _LPAREN ExpressaoLogica _RPAREN _KW_faca BlocoComando { $$ = new LWhile($3, $6); result->while_ = $$; }
;
For : _KW_para Atribuicao _KW_ate _INTEGER_ _KW_faca BlocoComando { $$ = new For1($2, $4, $6); result->for_ = $$; }
  | _KW_para Atribuicao _KW_ate _IDENT_ _KW_faca BlocoComando { $$ = new For2($2, $4, $6); result->for_ = $$; }
;
Goto : _KW_sovai _IDENT_ { $$ = new LGoto($2); result->goto_ = $$; }
;
Rotulo : _IDENT_ _COLON RegraComando { $$ = new LRotulo($1, $3); result->rotulo_ = $$; }
;
Struct : _KW_registro DefinicaoCampoStruct _KW_fim { $$ = new LStruct($2); result->struct_ = $$; }
;
DefinicaoCampoStruct : _IDENT_ _COLON RegraTipo _SEMI { $$ = new DefinicaoCampoStruct1($1, $3); result->definicaocampostruct_ = $$; }
  | _IDENT_ _COLON RegraTipo _SEMI DefinicaoCampoStruct { $$ = new DefinicaoCampoStruct2($1, $3, $5); result->definicaocampostruct_ = $$; }
;
AtribuicaoStruct : _IDENT_ _DOT _IDENT_ _COLONEQ Valor { $$ = new AtribuicaoStruct1($1, $3, $5); result->atribuicaostruct_ = $$; }
  | _IDENT_ _DOT _IDENT_ _COLONEQ Valor AtribuicaoStruct { $$ = new AtribuicaoStruct2($1, $3, $5, $6); result->atribuicaostruct_ = $$; }
;
OperadorRelacional : _GT { $$ = new OperadorRelacional1(); result->operadorrelacional_ = $$; }
  | _LT { $$ = new OperadorRelacional2(); result->operadorrelacional_ = $$; }
  | _LTGT { $$ = new OperadorRelacional3(); result->operadorrelacional_ = $$; }
  | _GTEQ { $$ = new OperadorRelacional4(); result->operadorrelacional_ = $$; }
  | _LDARROW { $$ = new OperadorRelacional5(); result->operadorrelacional_ = $$; }
  | _EQ { $$ = new OperadorRelacional6(); result->operadorrelacional_ = $$; }
;
OperadorLogico : _DAMP { $$ = new OperadorLogico1(); result->operadorlogico_ = $$; }
  | _DBAR { $$ = new OperadorLogico2(); result->operadorlogico_ = $$; }
  | _SYMB_18 { $$ = new OperadorLogico3(); result->operadorlogico_ = $$; }
  | Negacao { $$ = new OperadorLogicoNegacao($1); result->operadorlogico_ = $$; }
;
Negacao : _BANG { $$ = new LNegacao(); result->negacao_ = $$; }
;
OperadorAritmetico : _PLUS { $$ = new OperadorAritmetico1(); result->operadoraritmetico_ = $$; }
  | _MINUS { $$ = new OperadorAritmetico2(); result->operadoraritmetico_ = $$; }
  | _STAR { $$ = new OperadorAritmetico3(); result->operadoraritmetico_ = $$; }
  | _SLASH { $$ = new OperadorAritmetico4(); result->operadoraritmetico_ = $$; }
;
Case : _KW_caso _LPAREN Seletor _RPAREN _KW_de RegraSeletor _KW_fim { $$ = new LCase($3, $6); result->case_ = $$; }
;
RegraSeletor : Seletor _COLON Comando _SEMI { $$ = new RegraSeletor1($1, $3); result->regraseletor_ = $$; }
  | Seletor _COLON Comando _SEMI RegraSeletor { $$ = new RegraSeletor2($1, $3, $5); result->regraseletor_ = $$; }
;
Seletor : _INTEGER_ { $$ = new SeletorInteger($1); result->seletor_ = $$; }
  | _CHAR_ { $$ = new SeletorChar($1); result->seletor_ = $$; }
  | _IDENT_ { $$ = new SeletorIdent($1); result->seletor_ = $$; }
;
ChamadaFuncaoEProc : _IDENT_ _LPAREN ListaIdent _RPAREN { $$ = new LChamad($1, $3); result->chamadafuncaoeproc_ = $$; }
;
ListaIdent : _IDENT_ { $$ = new ListaIdentIdent($1); result->listaident_ = $$; }
  | _IDENT_ _COMMA ListaIdent { $$ = new ListaIdent1($1, $3); result->listaident_ = $$; }
;
Funcao : _KW_funcao _IDENT_ _LPAREN RegraBlocoVar _RPAREN _COLON RegraTipo BlocoVar BlocoComando _SEMI { $$ = new LFuncao($2, $4, $7, $8, $9); result->funcao_ = $$; }
;
Procedimento : _KW_procedimento _IDENT_ _LPAREN RegraBlocoVar _RPAREN BlocoVar BlocoComando { $$ = new Procedimento1($2, $4, $6, $7); result->procedimento_ = $$; }
  | _KW_procedimento _IDENT_ _LPAREN _RPAREN BlocoVar BlocoComando { $$ = new Procedimento2($2, $5, $6); result->procedimento_ = $$; }
;
ExpressaoAritmetica : Operando RegraAritmetica { $$ = new ExpAr($1, $2); result->expressaoaritmetica_ = $$; }
;
Operando : _INTEGER_ { $$ = new OperandoInteger($1); result->operando_ = $$; }
  | _DOUBLE_ { $$ = new OperandoDouble($1); result->operando_ = $$; }
  | _IDENT_ { $$ = new OperandoIdent($1); result->operando_ = $$; }
;
RegraAritmetica : OperadorAritmetico Operando { $$ = new RegraAritmetica1($1, $2); result->regraaritmetica_ = $$; }
  | OperadorAritmetico Operando RegraAritmetica { $$ = new RegraAritmetica2($1, $2, $3); result->regraaritmetica_ = $$; }
;
ExpressaoRelacional : Operando { $$ = new ExpressaoRelacionalOperando($1); result->expressaorelacional_ = $$; }
  | Operando RegraRelacional { $$ = new ExpressaoRelacional1($1, $2); result->expressaorelacional_ = $$; }
  | ExpressaoAritmetica RegraRelacional { $$ = new ExpressaoRelacional2($1, $2); result->expressaorelacional_ = $$; }
;
RegraRelacional : OperadorRelacional Operando { $$ = new RegraRelacional1($1, $2); result->regrarelacional_ = $$; }
  | OperadorRelacional ExpressaoAritmetica { $$ = new RegraRelacional2($1, $2); result->regrarelacional_ = $$; }
;
ExpressaoLogica : _KW_falso { $$ = new ExpressaoLogica_falso(); result->expressaologica_ = $$; }
  | _KW_falso RegraLogico { $$ = new ExpressaoLogica1($2); result->expressaologica_ = $$; }
  | _KW_verdadeiro { $$ = new ExpressaoLogica_verdadeiro(); result->expressaologica_ = $$; }
  | _KW_verdadeiro RegraLogico { $$ = new ExpressaoLogica2($2); result->expressaologica_ = $$; }
  | ExpressaoRelacional { $$ = new ExpressaoLogicaExpressaoRelacional($1); result->expressaologica_ = $$; }
  | ExpressaoRelacional RegraLogico { $$ = new ExpressaoLogica3($1, $2); result->expressaologica_ = $$; }
  | Negacao ExpressaoLogica { $$ = new ExpressaoLogica4($1, $2); result->expressaologica_ = $$; }
  | Negacao ExpressaoLogica RegraLogico { $$ = new ExpressaoLogica5($1, $2, $3); result->expressaologica_ = $$; }
;
RegraLogico : OperadorLogico ExpressaoLogica { $$ = new RegraLogico1($1, $2); result->regralogico_ = $$; }
  | OperadorLogico ExpressaoLogica RegraLogico { $$ = new RegraLogico2($1, $2, $3); result->regralogico_ = $$; }
;

%%


/* Entrypoint: parse Entry* from file. */
Entry* pEntry(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.entry_;
  }
}

/* Entrypoint: parse Entry* from string. */
Entry* psEntry(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.entry_;
  }
}

/* Entrypoint: parse BlocoDefinicoes* from file. */
BlocoDefinicoes* pBlocoDefinicoes(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocodefinicoes_;
  }
}

/* Entrypoint: parse BlocoDefinicoes* from string. */
BlocoDefinicoes* psBlocoDefinicoes(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocodefinicoes_;
  }
}

/* Entrypoint: parse BlocoFuncaoEProc* from file. */
BlocoFuncaoEProc* pBlocoFuncaoEProc(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocofuncaoeproc_;
  }
}

/* Entrypoint: parse BlocoFuncaoEProc* from string. */
BlocoFuncaoEProc* psBlocoFuncaoEProc(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocofuncaoeproc_;
  }
}

/* Entrypoint: parse BlocoConstante* from file. */
BlocoConstante* pBlocoConstante(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococonstante_;
  }
}

/* Entrypoint: parse BlocoConstante* from string. */
BlocoConstante* psBlocoConstante(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococonstante_;
  }
}

/* Entrypoint: parse RegraBlocoConstante* from file. */
RegraBlocoConstante* pRegraBlocoConstante(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablococonstante_;
  }
}

/* Entrypoint: parse RegraBlocoConstante* from string. */
RegraBlocoConstante* psRegraBlocoConstante(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablococonstante_;
  }
}

/* Entrypoint: parse BlocoTipo* from file. */
BlocoTipo* pBlocoTipo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocotipo_;
  }
}

/* Entrypoint: parse BlocoTipo* from string. */
BlocoTipo* psBlocoTipo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocotipo_;
  }
}

/* Entrypoint: parse RegraBlocoTipo* from file. */
RegraBlocoTipo* pRegraBlocoTipo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocotipo_;
  }
}

/* Entrypoint: parse RegraBlocoTipo* from string. */
RegraBlocoTipo* psRegraBlocoTipo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocotipo_;
  }
}

/* Entrypoint: parse BlocoVar* from file. */
BlocoVar* pBlocoVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocovar_;
  }
}

/* Entrypoint: parse BlocoVar* from string. */
BlocoVar* psBlocoVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocovar_;
  }
}

/* Entrypoint: parse RegraBlocoVar* from file. */
RegraBlocoVar* pRegraBlocoVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocovar_;
  }
}

/* Entrypoint: parse RegraBlocoVar* from string. */
RegraBlocoVar* psRegraBlocoVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocovar_;
  }
}

/* Entrypoint: parse BlocoComando* from file. */
BlocoComando* pBlocoComando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococomando_;
  }
}

/* Entrypoint: parse BlocoComando* from string. */
BlocoComando* psBlocoComando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococomando_;
  }
}

/* Entrypoint: parse RegraComando* from file. */
RegraComando* pRegraComando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regracomando_;
  }
}

/* Entrypoint: parse RegraComando* from string. */
RegraComando* psRegraComando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regracomando_;
  }
}

/* Entrypoint: parse Comando* from file. */
Comando* pComando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.comando_;
  }
}

/* Entrypoint: parse Comando* from string. */
Comando* psComando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.comando_;
  }
}

/* Entrypoint: parse Atribuicao* from file. */
Atribuicao* pAtribuicao(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicao_;
  }
}

/* Entrypoint: parse Atribuicao* from string. */
Atribuicao* psAtribuicao(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicao_;
  }
}

/* Entrypoint: parse SubEscrito* from file. */
SubEscrito* pSubEscrito(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.subescrito_;
  }
}

/* Entrypoint: parse SubEscrito* from string. */
SubEscrito* psSubEscrito(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.subescrito_;
  }
}

/* Entrypoint: parse RegraTipo* from file. */
RegraTipo* pRegraTipo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regratipo_;
  }
}

/* Entrypoint: parse RegraTipo* from string. */
RegraTipo* psRegraTipo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regratipo_;
  }
}

/* Entrypoint: parse TipoPrimitivo* from file. */
TipoPrimitivo* pTipoPrimitivo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoprimitivo_;
  }
}

/* Entrypoint: parse TipoPrimitivo* from string. */
TipoPrimitivo* psTipoPrimitivo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoprimitivo_;
  }
}

/* Entrypoint: parse Valor* from file. */
Valor* pValor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valor_;
  }
}

/* Entrypoint: parse Valor* from string. */
Valor* psValor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valor_;
  }
}

/* Entrypoint: parse TipoDerivado* from file. */
TipoDerivado* pTipoDerivado(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoderivado_;
  }
}

/* Entrypoint: parse TipoDerivado* from string. */
TipoDerivado* psTipoDerivado(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoderivado_;
  }
}

/* Entrypoint: parse Ponteiro* from file. */
Ponteiro* pPonteiro(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ponteiro_;
  }
}

/* Entrypoint: parse Ponteiro* from string. */
Ponteiro* psPonteiro(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ponteiro_;
  }
}

/* Entrypoint: parse Vetor* from file. */
Vetor* pVetor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vetor_;
  }
}

/* Entrypoint: parse Vetor* from string. */
Vetor* psVetor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vetor_;
  }
}

/* Entrypoint: parse If* from file. */
If* pIf(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse If* from string. */
If* psIf(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse While* from file. */
While* pWhile(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse While* from string. */
While* psWhile(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse For* from file. */
For* pFor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse For* from string. */
For* psFor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse Goto* from file. */
Goto* pGoto(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse Goto* from string. */
Goto* psGoto(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse Rotulo* from file. */
Rotulo* pRotulo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rotulo_;
  }
}

/* Entrypoint: parse Rotulo* from string. */
Rotulo* psRotulo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rotulo_;
  }
}

/* Entrypoint: parse Struct* from file. */
Struct* pStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse Struct* from string. */
Struct* psStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse DefinicaoCampoStruct* from file. */
DefinicaoCampoStruct* pDefinicaoCampoStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.definicaocampostruct_;
  }
}

/* Entrypoint: parse DefinicaoCampoStruct* from string. */
DefinicaoCampoStruct* psDefinicaoCampoStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.definicaocampostruct_;
  }
}

/* Entrypoint: parse AtribuicaoStruct* from file. */
AtribuicaoStruct* pAtribuicaoStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaostruct_;
  }
}

/* Entrypoint: parse AtribuicaoStruct* from string. */
AtribuicaoStruct* psAtribuicaoStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaostruct_;
  }
}

/* Entrypoint: parse OperadorRelacional* from file. */
OperadorRelacional* pOperadorRelacional(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorrelacional_;
  }
}

/* Entrypoint: parse OperadorRelacional* from string. */
OperadorRelacional* psOperadorRelacional(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorrelacional_;
  }
}

/* Entrypoint: parse OperadorLogico* from file. */
OperadorLogico* pOperadorLogico(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorlogico_;
  }
}

/* Entrypoint: parse OperadorLogico* from string. */
OperadorLogico* psOperadorLogico(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorlogico_;
  }
}

/* Entrypoint: parse Negacao* from file. */
Negacao* pNegacao(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.negacao_;
  }
}

/* Entrypoint: parse Negacao* from string. */
Negacao* psNegacao(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.negacao_;
  }
}

/* Entrypoint: parse OperadorAritmetico* from file. */
OperadorAritmetico* pOperadorAritmetico(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadoraritmetico_;
  }
}

/* Entrypoint: parse OperadorAritmetico* from string. */
OperadorAritmetico* psOperadorAritmetico(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadoraritmetico_;
  }
}

/* Entrypoint: parse Case* from file. */
Case* pCase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.case_;
  }
}

/* Entrypoint: parse Case* from string. */
Case* psCase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.case_;
  }
}

/* Entrypoint: parse RegraSeletor* from file. */
RegraSeletor* pRegraSeletor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraseletor_;
  }
}

/* Entrypoint: parse RegraSeletor* from string. */
RegraSeletor* psRegraSeletor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraseletor_;
  }
}

/* Entrypoint: parse Seletor* from file. */
Seletor* pSeletor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.seletor_;
  }
}

/* Entrypoint: parse Seletor* from string. */
Seletor* psSeletor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.seletor_;
  }
}

/* Entrypoint: parse ChamadaFuncaoEProc* from file. */
ChamadaFuncaoEProc* pChamadaFuncaoEProc(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.chamadafuncaoeproc_;
  }
}

/* Entrypoint: parse ChamadaFuncaoEProc* from string. */
ChamadaFuncaoEProc* psChamadaFuncaoEProc(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.chamadafuncaoeproc_;
  }
}

/* Entrypoint: parse ListaIdent* from file. */
ListaIdent* pListaIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listaident_;
  }
}

/* Entrypoint: parse ListaIdent* from string. */
ListaIdent* psListaIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listaident_;
  }
}

/* Entrypoint: parse Funcao* from file. */
Funcao* pFuncao(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcao_;
  }
}

/* Entrypoint: parse Funcao* from string. */
Funcao* psFuncao(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcao_;
  }
}

/* Entrypoint: parse Procedimento* from file. */
Procedimento* pProcedimento(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedimento_;
  }
}

/* Entrypoint: parse Procedimento* from string. */
Procedimento* psProcedimento(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedimento_;
  }
}

/* Entrypoint: parse ExpressaoAritmetica* from file. */
ExpressaoAritmetica* pExpressaoAritmetica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaoaritmetica_;
  }
}

/* Entrypoint: parse ExpressaoAritmetica* from string. */
ExpressaoAritmetica* psExpressaoAritmetica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaoaritmetica_;
  }
}

/* Entrypoint: parse Operando* from file. */
Operando* pOperando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operando_;
  }
}

/* Entrypoint: parse Operando* from string. */
Operando* psOperando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operando_;
  }
}

/* Entrypoint: parse RegraAritmetica* from file. */
RegraAritmetica* pRegraAritmetica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraaritmetica_;
  }
}

/* Entrypoint: parse RegraAritmetica* from string. */
RegraAritmetica* psRegraAritmetica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraaritmetica_;
  }
}

/* Entrypoint: parse ExpressaoRelacional* from file. */
ExpressaoRelacional* pExpressaoRelacional(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaorelacional_;
  }
}

/* Entrypoint: parse ExpressaoRelacional* from string. */
ExpressaoRelacional* psExpressaoRelacional(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaorelacional_;
  }
}

/* Entrypoint: parse RegraRelacional* from file. */
RegraRelacional* pRegraRelacional(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrarelacional_;
  }
}

/* Entrypoint: parse RegraRelacional* from string. */
RegraRelacional* psRegraRelacional(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrarelacional_;
  }
}

/* Entrypoint: parse ExpressaoLogica* from file. */
ExpressaoLogica* pExpressaoLogica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaologica_;
  }
}

/* Entrypoint: parse ExpressaoLogica* from string. */
ExpressaoLogica* psExpressaoLogica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaologica_;
  }
}

/* Entrypoint: parse RegraLogico* from file. */
RegraLogico* pRegraLogico(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regralogico_;
  }
}

/* Entrypoint: parse RegraLogico* from string. */
RegraLogico* psRegraLogico(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regralogico_;
  }
}



