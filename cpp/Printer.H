/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef PRINTER_HEADER
#define PRINTER_HEADER

#include "Absyn.H"
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>


/* Certain applications may improve performance by changing the buffer size */
#define BUFFER_INITIAL 2000
/* You may wish to change _L_PAREN or _R_PAREN */
#define _L_PAREN '('
#define _R_PAREN ')'

class PrintAbsyn : public Visitor
{
 protected:
  int _n_, _i_;
  /* The following are simple heuristics for rendering terminals */
  /* You may wish to change them */
  void render(Char c);
  void render(String s);
  void render(const char *s);
  void indent(void);
  void backup(void);
  void onEmptyLine(void);
  void removeTrailingSpaces(void);
  void removeTrailingWhitespace(void);
 public:
  PrintAbsyn(void);
  ~PrintAbsyn(void);
  char *print(Visitable *v);

  void visitEntry(Entry *p); /* abstract class */
  void visitLEntry(LEntry *p);
  void visitBlocoDefinicoes(BlocoDefinicoes *p); /* abstract class */
  void visitBlocoDefinicoes1(BlocoDefinicoes1 *p);
  void visitBlocoDefinicoes2(BlocoDefinicoes2 *p);
  void visitBlocoDefinicoes3(BlocoDefinicoes3 *p);
  void visitBlocoDefinicoes4(BlocoDefinicoes4 *p);
  void visitBlocoDefinicoes_(BlocoDefinicoes_ *p);
  void visitBlocoFuncaoEProc(BlocoFuncaoEProc *p); /* abstract class */
  void visitBlocoFuncaoEProcFuncao(BlocoFuncaoEProcFuncao *p);
  void visitBlocoFuncaoEProc1(BlocoFuncaoEProc1 *p);
  void visitBlocoFuncaoEProcProcedimento(BlocoFuncaoEProcProcedimento *p);
  void visitBlocoFuncaoEProc2(BlocoFuncaoEProc2 *p);
  void visitBlocoFuncaoEProc_(BlocoFuncaoEProc_ *p);
  void visitBlocoConstante(BlocoConstante *p); /* abstract class */
  void visitBlocoConstante1(BlocoConstante1 *p);
  void visitBlocoConstante_(BlocoConstante_ *p);
  void visitRegraBlocoConstante(RegraBlocoConstante *p); /* abstract class */
  void visitRegraBlocoConstante1(RegraBlocoConstante1 *p);
  void visitRegraBlocoConstante2(RegraBlocoConstante2 *p);
  void visitBlocoTipo(BlocoTipo *p); /* abstract class */
  void visitBlocoTipo1(BlocoTipo1 *p);
  void visitBlocoTipo_(BlocoTipo_ *p);
  void visitRegraBlocoTipo(RegraBlocoTipo *p); /* abstract class */
  void visitRegraBlocoTipo1(RegraBlocoTipo1 *p);
  void visitRegraBlocoTipo2(RegraBlocoTipo2 *p);
  void visitBlocoVar(BlocoVar *p); /* abstract class */
  void visitBlocoVar1(BlocoVar1 *p);
  void visitBlocoVar_(BlocoVar_ *p);
  void visitRegraBlocoVar(RegraBlocoVar *p); /* abstract class */
  void visitRegraBlocoVar1(RegraBlocoVar1 *p);
  void visitRegraBlocoVar2(RegraBlocoVar2 *p);
  void visitRegraBlocoVar3(RegraBlocoVar3 *p);
  void visitRegraBlocoVar4(RegraBlocoVar4 *p);
  void visitBlocoComando(BlocoComando *p); /* abstract class */
  void visitBlocoComando1(BlocoComando1 *p);
  void visitBlocoComando_(BlocoComando_ *p);
  void visitRegraComando(RegraComando *p); /* abstract class */
  void visitRegraComando1(RegraComando1 *p);
  void visitRegraComando2(RegraComando2 *p);
  void visitComando(Comando *p); /* abstract class */
  void visitComandoAtribuicao(ComandoAtribuicao *p);
  void visitComandoIf(ComandoIf *p);
  void visitComandoWhile(ComandoWhile *p);
  void visitComandoFor(ComandoFor *p);
  void visitComandoGoto(ComandoGoto *p);
  void visitComandoCase(ComandoCase *p);
  void visitComandoChamadaFuncaoEProc(ComandoChamadaFuncaoEProc *p);
  void visitAtribuicao(Atribuicao *p); /* abstract class */
  void visitAtribuicao1(Atribuicao1 *p);
  void visitAtribuicao2(Atribuicao2 *p);
  void visitAtribuicao3(Atribuicao3 *p);
  void visitAtribuicao4(Atribuicao4 *p);
  void visitAtribuicaoAtribuicaoStruct(AtribuicaoAtribuicaoStruct *p);
  void visitAtribuicao5(Atribuicao5 *p);
  void visitSubEscrito(SubEscrito *p); /* abstract class */
  void visitSubEscritoIdent(SubEscritoIdent *p);
  void visitSubEscritoInteger(SubEscritoInteger *p);
  void visitRegraTipo(RegraTipo *p); /* abstract class */
  void visitRegraTipoTipoPrimitivo(RegraTipoTipoPrimitivo *p);
  void visitRegraTipoTipoDerivado(RegraTipoTipoDerivado *p);
  void visitRegraTipoIdent(RegraTipoIdent *p);
  void visitTipoPrimitivo(TipoPrimitivo *p); /* abstract class */
  void visitTipoPrimitivo_int(TipoPrimitivo_int *p);
  void visitTipoPrimitivo_real(TipoPrimitivo_real *p);
  void visitTipoPrimitivo_char(TipoPrimitivo_char *p);
  void visitValor(Valor *p); /* abstract class */
  void visitValorInteger(ValorInteger *p);
  void visitValorDouble(ValorDouble *p);
  void visitValorChar(ValorChar *p);
  void visitValorString(ValorString *p);
  void visitValorExpressaoAritmetica(ValorExpressaoAritmetica *p);
  void visitTipoDerivado(TipoDerivado *p); /* abstract class */
  void visitTipoDerivadoPonteiro(TipoDerivadoPonteiro *p);
  void visitTipoDerivadoVetor(TipoDerivadoVetor *p);
  void visitTipoDerivadoStruct(TipoDerivadoStruct *p);
  void visitPonteiro(Ponteiro *p); /* abstract class */
  void visitPonteiro1(Ponteiro1 *p);
  void visitPonteiro2(Ponteiro2 *p);
  void visitVetor(Vetor *p); /* abstract class */
  void visitLVetor(LVetor *p);
  void visitIf(If *p); /* abstract class */
  void visitIf1(If1 *p);
  void visitIf2(If2 *p);
  void visitWhile(While *p); /* abstract class */
  void visitLWhile(LWhile *p);
  void visitFor(For *p); /* abstract class */
  void visitFor1(For1 *p);
  void visitFor2(For2 *p);
  void visitGoto(Goto *p); /* abstract class */
  void visitLGoto(LGoto *p);
  void visitRotulo(Rotulo *p); /* abstract class */
  void visitLRotulo(LRotulo *p);
  void visitStruct(Struct *p); /* abstract class */
  void visitLStruct(LStruct *p);
  void visitDefinicaoCampoStruct(DefinicaoCampoStruct *p); /* abstract class */
  void visitDefinicaoCampoStruct1(DefinicaoCampoStruct1 *p);
  void visitDefinicaoCampoStruct2(DefinicaoCampoStruct2 *p);
  void visitAtribuicaoStruct(AtribuicaoStruct *p); /* abstract class */
  void visitAtribuicaoStruct1(AtribuicaoStruct1 *p);
  void visitAtribuicaoStruct2(AtribuicaoStruct2 *p);
  void visitOperadorRelacional(OperadorRelacional *p); /* abstract class */
  void visitOperadorRelacional1(OperadorRelacional1 *p);
  void visitOperadorRelacional2(OperadorRelacional2 *p);
  void visitOperadorRelacional3(OperadorRelacional3 *p);
  void visitOperadorRelacional4(OperadorRelacional4 *p);
  void visitOperadorRelacional5(OperadorRelacional5 *p);
  void visitOperadorRelacional6(OperadorRelacional6 *p);
  void visitOperadorLogico(OperadorLogico *p); /* abstract class */
  void visitOperadorLogico1(OperadorLogico1 *p);
  void visitOperadorLogico2(OperadorLogico2 *p);
  void visitOperadorLogico3(OperadorLogico3 *p);
  void visitOperadorLogicoNegacao(OperadorLogicoNegacao *p);
  void visitNegacao(Negacao *p); /* abstract class */
  void visitLNegacao(LNegacao *p);
  void visitOperadorAritmetico(OperadorAritmetico *p); /* abstract class */
  void visitOperadorAritmetico1(OperadorAritmetico1 *p);
  void visitOperadorAritmetico2(OperadorAritmetico2 *p);
  void visitOperadorAritmetico3(OperadorAritmetico3 *p);
  void visitOperadorAritmetico4(OperadorAritmetico4 *p);
  void visitCase(Case *p); /* abstract class */
  void visitLCase(LCase *p);
  void visitRegraSeletor(RegraSeletor *p); /* abstract class */
  void visitRegraSeletor1(RegraSeletor1 *p);
  void visitRegraSeletor2(RegraSeletor2 *p);
  void visitSeletor(Seletor *p); /* abstract class */
  void visitSeletorInteger(SeletorInteger *p);
  void visitSeletorChar(SeletorChar *p);
  void visitSeletorIdent(SeletorIdent *p);
  void visitChamadaFuncaoEProc(ChamadaFuncaoEProc *p); /* abstract class */
  void visitLChamad(LChamad *p);
  void visitListaIdent(ListaIdent *p); /* abstract class */
  void visitListaIdentIdent(ListaIdentIdent *p);
  void visitListaIdent1(ListaIdent1 *p);
  void visitFuncao(Funcao *p); /* abstract class */
  void visitLFuncao(LFuncao *p);
  void visitProcedimento(Procedimento *p); /* abstract class */
  void visitProcedimento1(Procedimento1 *p);
  void visitProcedimento2(Procedimento2 *p);
  void visitExpressaoAritmetica(ExpressaoAritmetica *p); /* abstract class */
  void visitExpAr(ExpAr *p);
  void visitOperando(Operando *p); /* abstract class */
  void visitOperandoInteger(OperandoInteger *p);
  void visitOperandoDouble(OperandoDouble *p);
  void visitOperandoIdent(OperandoIdent *p);
  void visitRegraAritmetica(RegraAritmetica *p); /* abstract class */
  void visitRegraAritmetica1(RegraAritmetica1 *p);
  void visitRegraAritmetica2(RegraAritmetica2 *p);
  void visitExpressaoRelacional(ExpressaoRelacional *p); /* abstract class */
  void visitExpressaoRelacionalOperando(ExpressaoRelacionalOperando *p);
  void visitExpressaoRelacional1(ExpressaoRelacional1 *p);
  void visitExpressaoRelacional2(ExpressaoRelacional2 *p);
  void visitRegraRelacional(RegraRelacional *p); /* abstract class */
  void visitRegraRelacional1(RegraRelacional1 *p);
  void visitRegraRelacional2(RegraRelacional2 *p);
  void visitExpressaoLogica(ExpressaoLogica *p); /* abstract class */
  void visitExpressaoLogica_falso(ExpressaoLogica_falso *p);
  void visitExpressaoLogica1(ExpressaoLogica1 *p);
  void visitExpressaoLogica_verdadeiro(ExpressaoLogica_verdadeiro *p);
  void visitExpressaoLogica2(ExpressaoLogica2 *p);
  void visitExpressaoLogicaExpressaoRelacional(ExpressaoLogicaExpressaoRelacional *p);
  void visitExpressaoLogica3(ExpressaoLogica3 *p);
  void visitExpressaoLogica4(ExpressaoLogica4 *p);
  void visitExpressaoLogica5(ExpressaoLogica5 *p);
  void visitRegraLogico(RegraLogico *p); /* abstract class */
  void visitRegraLogico1(RegraLogico1 *p);
  void visitRegraLogico2(RegraLogico2 *p);

  void visitInteger(Integer i);
  void visitDouble(Double d);
  void visitChar(Char c);
  void visitString(String s);
  void visitIdent(String s);
 protected:
  char *buf_;
  size_t cur_, buf_size;

  void inline bufAppend(const char *s)
  {
    size_t end = cur_ + strlen(s);
    if (end >= buf_size) {
      do buf_size *= 2; /* Double the buffer size */
      while (end >= buf_size);
      resizeBuffer();
    }
    strcpy(&buf_[cur_], s);
    cur_ = end;
  }

  void inline bufAppend(const char c)
  {
    if (cur_ + 1 >= buf_size)
    {
      buf_size *= 2; /* Double the buffer size */
      resizeBuffer();
    }
    buf_[cur_] = c;
    buf_[++cur_] = 0;
  }

  void inline bufAppend(String str)
  {
    const char *s = str.c_str();
    bufAppend(s);
  }
  void inline bufReset(void)
  {
    if (buf_) delete[] buf_;
    buf_size = BUFFER_INITIAL;
    buf_ = new char[buf_size];
    memset(buf_, 0, buf_size);
    cur_ = 0;
  }

  void inline resizeBuffer(void)
  {
    char *temp = new char[buf_size];
    if (buf_)
    {
      strcpy(temp, buf_);
      delete[] buf_;
    }
    buf_ = temp;
  }
};



class ShowAbsyn : public Visitor
{
 public:
  ShowAbsyn(void);
  ~ShowAbsyn(void);
  char *show(Visitable *v);

  void visitEntry(Entry *p); /* abstract class */
  void visitLEntry(LEntry *p);
  void visitBlocoDefinicoes(BlocoDefinicoes *p); /* abstract class */
  void visitBlocoDefinicoes1(BlocoDefinicoes1 *p);
  void visitBlocoDefinicoes2(BlocoDefinicoes2 *p);
  void visitBlocoDefinicoes3(BlocoDefinicoes3 *p);
  void visitBlocoDefinicoes4(BlocoDefinicoes4 *p);
  void visitBlocoDefinicoes_(BlocoDefinicoes_ *p);
  void visitBlocoFuncaoEProc(BlocoFuncaoEProc *p); /* abstract class */
  void visitBlocoFuncaoEProcFuncao(BlocoFuncaoEProcFuncao *p);
  void visitBlocoFuncaoEProc1(BlocoFuncaoEProc1 *p);
  void visitBlocoFuncaoEProcProcedimento(BlocoFuncaoEProcProcedimento *p);
  void visitBlocoFuncaoEProc2(BlocoFuncaoEProc2 *p);
  void visitBlocoFuncaoEProc_(BlocoFuncaoEProc_ *p);
  void visitBlocoConstante(BlocoConstante *p); /* abstract class */
  void visitBlocoConstante1(BlocoConstante1 *p);
  void visitBlocoConstante_(BlocoConstante_ *p);
  void visitRegraBlocoConstante(RegraBlocoConstante *p); /* abstract class */
  void visitRegraBlocoConstante1(RegraBlocoConstante1 *p);
  void visitRegraBlocoConstante2(RegraBlocoConstante2 *p);
  void visitBlocoTipo(BlocoTipo *p); /* abstract class */
  void visitBlocoTipo1(BlocoTipo1 *p);
  void visitBlocoTipo_(BlocoTipo_ *p);
  void visitRegraBlocoTipo(RegraBlocoTipo *p); /* abstract class */
  void visitRegraBlocoTipo1(RegraBlocoTipo1 *p);
  void visitRegraBlocoTipo2(RegraBlocoTipo2 *p);
  void visitBlocoVar(BlocoVar *p); /* abstract class */
  void visitBlocoVar1(BlocoVar1 *p);
  void visitBlocoVar_(BlocoVar_ *p);
  void visitRegraBlocoVar(RegraBlocoVar *p); /* abstract class */
  void visitRegraBlocoVar1(RegraBlocoVar1 *p);
  void visitRegraBlocoVar2(RegraBlocoVar2 *p);
  void visitRegraBlocoVar3(RegraBlocoVar3 *p);
  void visitRegraBlocoVar4(RegraBlocoVar4 *p);
  void visitBlocoComando(BlocoComando *p); /* abstract class */
  void visitBlocoComando1(BlocoComando1 *p);
  void visitBlocoComando_(BlocoComando_ *p);
  void visitRegraComando(RegraComando *p); /* abstract class */
  void visitRegraComando1(RegraComando1 *p);
  void visitRegraComando2(RegraComando2 *p);
  void visitComando(Comando *p); /* abstract class */
  void visitComandoAtribuicao(ComandoAtribuicao *p);
  void visitComandoIf(ComandoIf *p);
  void visitComandoWhile(ComandoWhile *p);
  void visitComandoFor(ComandoFor *p);
  void visitComandoGoto(ComandoGoto *p);
  void visitComandoCase(ComandoCase *p);
  void visitComandoChamadaFuncaoEProc(ComandoChamadaFuncaoEProc *p);
  void visitAtribuicao(Atribuicao *p); /* abstract class */
  void visitAtribuicao1(Atribuicao1 *p);
  void visitAtribuicao2(Atribuicao2 *p);
  void visitAtribuicao3(Atribuicao3 *p);
  void visitAtribuicao4(Atribuicao4 *p);
  void visitAtribuicaoAtribuicaoStruct(AtribuicaoAtribuicaoStruct *p);
  void visitAtribuicao5(Atribuicao5 *p);
  void visitSubEscrito(SubEscrito *p); /* abstract class */
  void visitSubEscritoIdent(SubEscritoIdent *p);
  void visitSubEscritoInteger(SubEscritoInteger *p);
  void visitRegraTipo(RegraTipo *p); /* abstract class */
  void visitRegraTipoTipoPrimitivo(RegraTipoTipoPrimitivo *p);
  void visitRegraTipoTipoDerivado(RegraTipoTipoDerivado *p);
  void visitRegraTipoIdent(RegraTipoIdent *p);
  void visitTipoPrimitivo(TipoPrimitivo *p); /* abstract class */
  void visitTipoPrimitivo_int(TipoPrimitivo_int *p);
  void visitTipoPrimitivo_real(TipoPrimitivo_real *p);
  void visitTipoPrimitivo_char(TipoPrimitivo_char *p);
  void visitValor(Valor *p); /* abstract class */
  void visitValorInteger(ValorInteger *p);
  void visitValorDouble(ValorDouble *p);
  void visitValorChar(ValorChar *p);
  void visitValorString(ValorString *p);
  void visitValorExpressaoAritmetica(ValorExpressaoAritmetica *p);
  void visitTipoDerivado(TipoDerivado *p); /* abstract class */
  void visitTipoDerivadoPonteiro(TipoDerivadoPonteiro *p);
  void visitTipoDerivadoVetor(TipoDerivadoVetor *p);
  void visitTipoDerivadoStruct(TipoDerivadoStruct *p);
  void visitPonteiro(Ponteiro *p); /* abstract class */
  void visitPonteiro1(Ponteiro1 *p);
  void visitPonteiro2(Ponteiro2 *p);
  void visitVetor(Vetor *p); /* abstract class */
  void visitLVetor(LVetor *p);
  void visitIf(If *p); /* abstract class */
  void visitIf1(If1 *p);
  void visitIf2(If2 *p);
  void visitWhile(While *p); /* abstract class */
  void visitLWhile(LWhile *p);
  void visitFor(For *p); /* abstract class */
  void visitFor1(For1 *p);
  void visitFor2(For2 *p);
  void visitGoto(Goto *p); /* abstract class */
  void visitLGoto(LGoto *p);
  void visitRotulo(Rotulo *p); /* abstract class */
  void visitLRotulo(LRotulo *p);
  void visitStruct(Struct *p); /* abstract class */
  void visitLStruct(LStruct *p);
  void visitDefinicaoCampoStruct(DefinicaoCampoStruct *p); /* abstract class */
  void visitDefinicaoCampoStruct1(DefinicaoCampoStruct1 *p);
  void visitDefinicaoCampoStruct2(DefinicaoCampoStruct2 *p);
  void visitAtribuicaoStruct(AtribuicaoStruct *p); /* abstract class */
  void visitAtribuicaoStruct1(AtribuicaoStruct1 *p);
  void visitAtribuicaoStruct2(AtribuicaoStruct2 *p);
  void visitOperadorRelacional(OperadorRelacional *p); /* abstract class */
  void visitOperadorRelacional1(OperadorRelacional1 *p);
  void visitOperadorRelacional2(OperadorRelacional2 *p);
  void visitOperadorRelacional3(OperadorRelacional3 *p);
  void visitOperadorRelacional4(OperadorRelacional4 *p);
  void visitOperadorRelacional5(OperadorRelacional5 *p);
  void visitOperadorRelacional6(OperadorRelacional6 *p);
  void visitOperadorLogico(OperadorLogico *p); /* abstract class */
  void visitOperadorLogico1(OperadorLogico1 *p);
  void visitOperadorLogico2(OperadorLogico2 *p);
  void visitOperadorLogico3(OperadorLogico3 *p);
  void visitOperadorLogicoNegacao(OperadorLogicoNegacao *p);
  void visitNegacao(Negacao *p); /* abstract class */
  void visitLNegacao(LNegacao *p);
  void visitOperadorAritmetico(OperadorAritmetico *p); /* abstract class */
  void visitOperadorAritmetico1(OperadorAritmetico1 *p);
  void visitOperadorAritmetico2(OperadorAritmetico2 *p);
  void visitOperadorAritmetico3(OperadorAritmetico3 *p);
  void visitOperadorAritmetico4(OperadorAritmetico4 *p);
  void visitCase(Case *p); /* abstract class */
  void visitLCase(LCase *p);
  void visitRegraSeletor(RegraSeletor *p); /* abstract class */
  void visitRegraSeletor1(RegraSeletor1 *p);
  void visitRegraSeletor2(RegraSeletor2 *p);
  void visitSeletor(Seletor *p); /* abstract class */
  void visitSeletorInteger(SeletorInteger *p);
  void visitSeletorChar(SeletorChar *p);
  void visitSeletorIdent(SeletorIdent *p);
  void visitChamadaFuncaoEProc(ChamadaFuncaoEProc *p); /* abstract class */
  void visitLChamad(LChamad *p);
  void visitListaIdent(ListaIdent *p); /* abstract class */
  void visitListaIdentIdent(ListaIdentIdent *p);
  void visitListaIdent1(ListaIdent1 *p);
  void visitFuncao(Funcao *p); /* abstract class */
  void visitLFuncao(LFuncao *p);
  void visitProcedimento(Procedimento *p); /* abstract class */
  void visitProcedimento1(Procedimento1 *p);
  void visitProcedimento2(Procedimento2 *p);
  void visitExpressaoAritmetica(ExpressaoAritmetica *p); /* abstract class */
  void visitExpAr(ExpAr *p);
  void visitOperando(Operando *p); /* abstract class */
  void visitOperandoInteger(OperandoInteger *p);
  void visitOperandoDouble(OperandoDouble *p);
  void visitOperandoIdent(OperandoIdent *p);
  void visitRegraAritmetica(RegraAritmetica *p); /* abstract class */
  void visitRegraAritmetica1(RegraAritmetica1 *p);
  void visitRegraAritmetica2(RegraAritmetica2 *p);
  void visitExpressaoRelacional(ExpressaoRelacional *p); /* abstract class */
  void visitExpressaoRelacionalOperando(ExpressaoRelacionalOperando *p);
  void visitExpressaoRelacional1(ExpressaoRelacional1 *p);
  void visitExpressaoRelacional2(ExpressaoRelacional2 *p);
  void visitRegraRelacional(RegraRelacional *p); /* abstract class */
  void visitRegraRelacional1(RegraRelacional1 *p);
  void visitRegraRelacional2(RegraRelacional2 *p);
  void visitExpressaoLogica(ExpressaoLogica *p); /* abstract class */
  void visitExpressaoLogica_falso(ExpressaoLogica_falso *p);
  void visitExpressaoLogica1(ExpressaoLogica1 *p);
  void visitExpressaoLogica_verdadeiro(ExpressaoLogica_verdadeiro *p);
  void visitExpressaoLogica2(ExpressaoLogica2 *p);
  void visitExpressaoLogicaExpressaoRelacional(ExpressaoLogicaExpressaoRelacional *p);
  void visitExpressaoLogica3(ExpressaoLogica3 *p);
  void visitExpressaoLogica4(ExpressaoLogica4 *p);
  void visitExpressaoLogica5(ExpressaoLogica5 *p);
  void visitRegraLogico(RegraLogico *p); /* abstract class */
  void visitRegraLogico1(RegraLogico1 *p);
  void visitRegraLogico2(RegraLogico2 *p);

  void visitInteger(Integer i);
  void visitDouble(Double d);
  void visitChar(Char c);
  void visitString(String s);
  void visitIdent(String s);
 protected:
  char *buf_;
  size_t cur_, buf_size;

  void inline bufAppend(const char *s)
  {
    size_t end = cur_ + strlen(s);
    if (end >= buf_size) {
      do buf_size *= 2; /* Double the buffer size */
      while (end >= buf_size);
      resizeBuffer();
    }
    strcpy(&buf_[cur_], s);
    cur_ = end;
  }

  void inline bufAppend(const char c)
  {
    if (cur_ + 1 >= buf_size)
    {
      buf_size *= 2; /* Double the buffer size */
      resizeBuffer();
    }
    buf_[cur_] = c;
    buf_[++cur_] = 0;
  }

  void inline bufAppend(String str)
  {
    const char *s = str.c_str();
    bufAppend(s);
  }
  void inline bufReset(void)
  {
    if (buf_) delete[] buf_;
    buf_size = BUFFER_INITIAL;
    buf_ = new char[buf_size];
    memset(buf_, 0, buf_size);
    cur_ = 0;
  }

  void inline resizeBuffer(void)
  {
    char *temp = new char[buf_size];
    if (buf_)
    {
      strcpy(temp, buf_);
      delete[] buf_;
    }
    buf_ = temp;
  }
};




#endif

