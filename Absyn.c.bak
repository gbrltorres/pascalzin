/* File generated by the BNF Converter (bnfc 2.9.4). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   L1    ********************/

Entry make_L1(Ident p1, BlocoConstante p2, BlocoTipo p3, BlocoVar p4, BlocoComando p5)
{
    Entry tmp = (Entry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L1!\n");
        exit(1);
    }
    tmp->kind = is_L1;
    tmp->u.l1_.ident_ = p1;
    tmp->u.l1_.blococonstante_ = p2;
    tmp->u.l1_.blocotipo_ = p3;
    tmp->u.l1_.blocovar_ = p4;
    tmp->u.l1_.blococomando_ = p5;
    return tmp;
}

/********************   BlocoConstante1    ********************/

BlocoConstante make_BlocoConstante1(RegraBlocoConstante p1)
{
    BlocoConstante tmp = (BlocoConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoConstante1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoConstante1;
    tmp->u.blococonstante1_.regrablococonstante_ = p1;
    return tmp;
}

/********************   BlocoConstante2    ********************/

BlocoConstante make_BlocoConstante2()
{
    BlocoConstante tmp = (BlocoConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoConstante2!\n");
        exit(1);
    }
    tmp->kind = is_BlocoConstante2;
    return tmp;
}

/********************   RegraBlocoConstante1    ********************/

RegraBlocoConstante make_RegraBlocoConstante1(Ident p1, Valor p2)
{
    RegraBlocoConstante tmp = (RegraBlocoConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraBlocoConstante1!\n");
        exit(1);
    }
    tmp->kind = is_RegraBlocoConstante1;
    tmp->u.regrablococonstante1_.ident_ = p1;
    tmp->u.regrablococonstante1_.valor_ = p2;
    return tmp;
}

/********************   RegraBlocoConstante2    ********************/

RegraBlocoConstante make_RegraBlocoConstante2(Ident p1, Valor p2, RegraBlocoConstante p3)
{
    RegraBlocoConstante tmp = (RegraBlocoConstante) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraBlocoConstante2!\n");
        exit(1);
    }
    tmp->kind = is_RegraBlocoConstante2;
    tmp->u.regrablococonstante2_.ident_ = p1;
    tmp->u.regrablococonstante2_.valor_ = p2;
    tmp->u.regrablococonstante2_.regrablococonstante_ = p3;
    return tmp;
}

/********************   BlocoTipo1    ********************/

BlocoTipo make_BlocoTipo1(RegraBlocoTipo p1)
{
    BlocoTipo tmp = (BlocoTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoTipo1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoTipo1;
    tmp->u.blocotipo1_.regrablocotipo_ = p1;
    return tmp;
}

/********************   BlocoTipo_    ********************/

BlocoTipo make_BlocoTipo_()
{
    BlocoTipo tmp = (BlocoTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoTipo_!\n");
        exit(1);
    }
    tmp->kind = is_BlocoTipo_;
    return tmp;
}

/********************   RegraBlocoTipo1    ********************/

RegraBlocoTipo make_RegraBlocoTipo1(Ident p1, RegraTipo p2)
{
    RegraBlocoTipo tmp = (RegraBlocoTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraBlocoTipo1!\n");
        exit(1);
    }
    tmp->kind = is_RegraBlocoTipo1;
    tmp->u.regrablocotipo1_.ident_ = p1;
    tmp->u.regrablocotipo1_.regratipo_ = p2;
    return tmp;
}

/********************   RegraBlocoTipo2    ********************/

RegraBlocoTipo make_RegraBlocoTipo2(Ident p1, RegraTipo p2, RegraBlocoTipo p3)
{
    RegraBlocoTipo tmp = (RegraBlocoTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraBlocoTipo2!\n");
        exit(1);
    }
    tmp->kind = is_RegraBlocoTipo2;
    tmp->u.regrablocotipo2_.ident_ = p1;
    tmp->u.regrablocotipo2_.regratipo_ = p2;
    tmp->u.regrablocotipo2_.regrablocotipo_ = p3;
    return tmp;
}

/********************   BlocoVar1    ********************/

BlocoVar make_BlocoVar1(RegraBlocoVar p1)
{
    BlocoVar tmp = (BlocoVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoVar1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoVar1;
    tmp->u.blocovar1_.regrablocovar_ = p1;
    return tmp;
}

/********************   BlocoVar2    ********************/

BlocoVar make_BlocoVar2()
{
    BlocoVar tmp = (BlocoVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoVar2!\n");
        exit(1);
    }
    tmp->kind = is_BlocoVar2;
    return tmp;
}

/********************   RegraBlocoVar1    ********************/

RegraBlocoVar make_RegraBlocoVar1(Ident p1, RegraTipo p2)
{
    RegraBlocoVar tmp = (RegraBlocoVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraBlocoVar1!\n");
        exit(1);
    }
    tmp->kind = is_RegraBlocoVar1;
    tmp->u.regrablocovar1_.ident_ = p1;
    tmp->u.regrablocovar1_.regratipo_ = p2;
    return tmp;
}

/********************   RegraBlocoVar2    ********************/

RegraBlocoVar make_RegraBlocoVar2(Ident p1, RegraTipo p2, RegraBlocoVar p3)
{
    RegraBlocoVar tmp = (RegraBlocoVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraBlocoVar2!\n");
        exit(1);
    }
    tmp->kind = is_RegraBlocoVar2;
    tmp->u.regrablocovar2_.ident_ = p1;
    tmp->u.regrablocovar2_.regratipo_ = p2;
    tmp->u.regrablocovar2_.regrablocovar_ = p3;
    return tmp;
}

/********************   BlocoComando1    ********************/

BlocoComando make_BlocoComando1(RegraComando p1)
{
    BlocoComando tmp = (BlocoComando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoComando1!\n");
        exit(1);
    }
    tmp->kind = is_BlocoComando1;
    tmp->u.blococomando1_.regracomando_ = p1;
    return tmp;
}

/********************   BlocoComando2    ********************/

BlocoComando make_BlocoComando2()
{
    BlocoComando tmp = (BlocoComando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BlocoComando2!\n");
        exit(1);
    }
    tmp->kind = is_BlocoComando2;
    return tmp;
}

/********************   RegraComando1    ********************/

RegraComando make_RegraComando1(Comando p1)
{
    RegraComando tmp = (RegraComando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraComando1!\n");
        exit(1);
    }
    tmp->kind = is_RegraComando1;
    tmp->u.regracomando1_.comando_ = p1;
    return tmp;
}

/********************   RegraComando2    ********************/

RegraComando make_RegraComando2(Comando p1, RegraComando p2)
{
    RegraComando tmp = (RegraComando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraComando2!\n");
        exit(1);
    }
    tmp->kind = is_RegraComando2;
    tmp->u.regracomando2_.comando_ = p1;
    tmp->u.regracomando2_.regracomando_ = p2;
    return tmp;
}

/********************   ComandoAtribuicao    ********************/

Comando make_ComandoAtribuicao(Atribuicao p1)
{
    Comando tmp = (Comando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ComandoAtribuicao!\n");
        exit(1);
    }
    tmp->kind = is_ComandoAtribuicao;
    tmp->u.comandoatribuicao_.atribuicao_ = p1;
    return tmp;
}

/********************   ComandoIf    ********************/

Comando make_ComandoIf(If p1)
{
    Comando tmp = (Comando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ComandoIf!\n");
        exit(1);
    }
    tmp->kind = is_ComandoIf;
    tmp->u.comandoif_.if_ = p1;
    return tmp;
}

/********************   ComandoWhile    ********************/

Comando make_ComandoWhile(While p1)
{
    Comando tmp = (Comando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ComandoWhile!\n");
        exit(1);
    }
    tmp->kind = is_ComandoWhile;
    tmp->u.comandowhile_.while_ = p1;
    return tmp;
}

/********************   ComandoFor    ********************/

Comando make_ComandoFor(For p1)
{
    Comando tmp = (Comando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ComandoFor!\n");
        exit(1);
    }
    tmp->kind = is_ComandoFor;
    tmp->u.comandofor_.for_ = p1;
    return tmp;
}

/********************   ComandoGoto    ********************/

Comando make_ComandoGoto(Goto p1)
{
    Comando tmp = (Comando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ComandoGoto!\n");
        exit(1);
    }
    tmp->kind = is_ComandoGoto;
    tmp->u.comandogoto_.goto_ = p1;
    return tmp;
}

/********************   Atribuicao1    ********************/

Atribuicao make_Atribuicao1(Ident p1, Valor p2)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Atribuicao1!\n");
        exit(1);
    }
    tmp->kind = is_Atribuicao1;
    tmp->u.atribuicao1_.ident_ = p1;
    tmp->u.atribuicao1_.valor_ = p2;
    return tmp;
}

/********************   Atribuicao2    ********************/

Atribuicao make_Atribuicao2(Ident p1, SubEscrito p2, Valor p3)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Atribuicao2!\n");
        exit(1);
    }
    tmp->kind = is_Atribuicao2;
    tmp->u.atribuicao2_.ident_ = p1;
    tmp->u.atribuicao2_.subescrito_ = p2;
    tmp->u.atribuicao2_.valor_ = p3;
    return tmp;
}

/********************   Atribuicao3    ********************/

Atribuicao make_Atribuicao3(Ident p1, Valor p2)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Atribuicao3!\n");
        exit(1);
    }
    tmp->kind = is_Atribuicao3;
    tmp->u.atribuicao3_.ident_ = p1;
    tmp->u.atribuicao3_.valor_ = p2;
    return tmp;
}

/********************   AtribuicaoAtribuicaoStruct    ********************/

Atribuicao make_AtribuicaoAtribuicaoStruct(AtribuicaoStruct p1)
{
    Atribuicao tmp = (Atribuicao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoAtribuicaoStruct!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoAtribuicaoStruct;
    tmp->u.atribuicaoatribuicaostruct_.atribuicaostruct_ = p1;
    return tmp;
}

/********************   SubEscritoIdent    ********************/

SubEscrito make_SubEscritoIdent(Ident p1)
{
    SubEscrito tmp = (SubEscrito) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SubEscritoIdent!\n");
        exit(1);
    }
    tmp->kind = is_SubEscritoIdent;
    tmp->u.subescritoident_.ident_ = p1;
    return tmp;
}

/********************   SubEscritoInteger    ********************/

SubEscrito make_SubEscritoInteger(Integer p1)
{
    SubEscrito tmp = (SubEscrito) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SubEscritoInteger!\n");
        exit(1);
    }
    tmp->kind = is_SubEscritoInteger;
    tmp->u.subescritointeger_.integer_ = p1;
    return tmp;
}

/********************   RegraTipoTipoPrimitivo    ********************/

RegraTipo make_RegraTipoTipoPrimitivo(TipoPrimitivo p1)
{
    RegraTipo tmp = (RegraTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraTipoTipoPrimitivo!\n");
        exit(1);
    }
    tmp->kind = is_RegraTipoTipoPrimitivo;
    tmp->u.regratipotipoprimitivo_.tipoprimitivo_ = p1;
    return tmp;
}

/********************   RegraTipoTipoDerivado    ********************/

RegraTipo make_RegraTipoTipoDerivado(TipoDerivado p1)
{
    RegraTipo tmp = (RegraTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraTipoTipoDerivado!\n");
        exit(1);
    }
    tmp->kind = is_RegraTipoTipoDerivado;
    tmp->u.regratipotipoderivado_.tipoderivado_ = p1;
    return tmp;
}

/********************   RegraTipoIdent    ********************/

RegraTipo make_RegraTipoIdent(Ident p1)
{
    RegraTipo tmp = (RegraTipo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraTipoIdent!\n");
        exit(1);
    }
    tmp->kind = is_RegraTipoIdent;
    tmp->u.regratipoident_.ident_ = p1;
    return tmp;
}

/********************   TipoPrimitivo_int    ********************/

TipoPrimitivo make_TipoPrimitivo_int()
{
    TipoPrimitivo tmp = (TipoPrimitivo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TipoPrimitivo_int!\n");
        exit(1);
    }
    tmp->kind = is_TipoPrimitivo_int;
    return tmp;
}

/********************   TipoPrimitivo_real    ********************/

TipoPrimitivo make_TipoPrimitivo_real()
{
    TipoPrimitivo tmp = (TipoPrimitivo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TipoPrimitivo_real!\n");
        exit(1);
    }
    tmp->kind = is_TipoPrimitivo_real;
    return tmp;
}

/********************   TipoPrimitivo_char    ********************/

TipoPrimitivo make_TipoPrimitivo_char()
{
    TipoPrimitivo tmp = (TipoPrimitivo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TipoPrimitivo_char!\n");
        exit(1);
    }
    tmp->kind = is_TipoPrimitivo_char;
    return tmp;
}

/********************   ValorInteger    ********************/

Valor make_ValorInteger(Integer p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorInteger!\n");
        exit(1);
    }
    tmp->kind = is_ValorInteger;
    tmp->u.valorinteger_.integer_ = p1;
    return tmp;
}

/********************   ValorDouble    ********************/

Valor make_ValorDouble(Double p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorDouble!\n");
        exit(1);
    }
    tmp->kind = is_ValorDouble;
    tmp->u.valordouble_.double_ = p1;
    return tmp;
}

/********************   ValorChar    ********************/

Valor make_ValorChar(Char p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorChar!\n");
        exit(1);
    }
    tmp->kind = is_ValorChar;
    tmp->u.valorchar_.char_ = p1;
    return tmp;
}

/********************   ValorString    ********************/

Valor make_ValorString(String p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorString!\n");
        exit(1);
    }
    tmp->kind = is_ValorString;
    tmp->u.valorstring_.string_ = p1;
    return tmp;
}

/********************   ValorExpressaoAritmetica    ********************/

Valor make_ValorExpressaoAritmetica(ExpressaoAritmetica p1)
{
    Valor tmp = (Valor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValorExpressaoAritmetica!\n");
        exit(1);
    }
    tmp->kind = is_ValorExpressaoAritmetica;
    tmp->u.valorexpressaoaritmetica_.expressaoaritmetica_ = p1;
    return tmp;
}

/********************   TipoDerivadoPonteiro    ********************/

TipoDerivado make_TipoDerivadoPonteiro(Ponteiro p1)
{
    TipoDerivado tmp = (TipoDerivado) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TipoDerivadoPonteiro!\n");
        exit(1);
    }
    tmp->kind = is_TipoDerivadoPonteiro;
    tmp->u.tipoderivadoponteiro_.ponteiro_ = p1;
    return tmp;
}

/********************   TipoDerivadoVetor    ********************/

TipoDerivado make_TipoDerivadoVetor(Vetor p1)
{
    TipoDerivado tmp = (TipoDerivado) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TipoDerivadoVetor!\n");
        exit(1);
    }
    tmp->kind = is_TipoDerivadoVetor;
    tmp->u.tipoderivadovetor_.vetor_ = p1;
    return tmp;
}

/********************   TipoDerivadoStruct    ********************/

TipoDerivado make_TipoDerivadoStruct(Struct p1)
{
    TipoDerivado tmp = (TipoDerivado) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TipoDerivadoStruct!\n");
        exit(1);
    }
    tmp->kind = is_TipoDerivadoStruct;
    tmp->u.tipoderivadostruct_.struct_ = p1;
    return tmp;
}

/********************   Ponteiro1    ********************/

Ponteiro make_Ponteiro1(TipoPrimitivo p1)
{
    Ponteiro tmp = (Ponteiro) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Ponteiro1!\n");
        exit(1);
    }
    tmp->kind = is_Ponteiro1;
    tmp->u.ponteiro1_.tipoprimitivo_ = p1;
    return tmp;
}

/********************   Ponteiro2    ********************/

Ponteiro make_Ponteiro2(TipoDerivado p1)
{
    Ponteiro tmp = (Ponteiro) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Ponteiro2!\n");
        exit(1);
    }
    tmp->kind = is_Ponteiro2;
    tmp->u.ponteiro2_.tipoderivado_ = p1;
    return tmp;
}

/********************   L7    ********************/

Vetor make_L7(Integer p1, Integer p2, TipoPrimitivo p3)
{
    Vetor tmp = (Vetor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L7!\n");
        exit(1);
    }
    tmp->kind = is_L7;
    tmp->u.l7_.integer_1 = p1;
    tmp->u.l7_.integer_2 = p2;
    tmp->u.l7_.tipoprimitivo_ = p3;
    return tmp;
}

/********************   If1    ********************/

If make_If1(ExpressaoLogica p1, BlocoComando p2)
{
    If tmp = (If) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating If1!\n");
        exit(1);
    }
    tmp->kind = is_If1;
    tmp->u.if1_.expressaologica_ = p1;
    tmp->u.if1_.blococomando_ = p2;
    return tmp;
}

/********************   If2    ********************/

If make_If2(ExpressaoLogica p1, BlocoComando p2, BlocoComando p3)
{
    If tmp = (If) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating If2!\n");
        exit(1);
    }
    tmp->kind = is_If2;
    tmp->u.if2_.expressaologica_ = p1;
    tmp->u.if2_.blococomando_1 = p2;
    tmp->u.if2_.blococomando_2 = p3;
    return tmp;
}

/********************   L8    ********************/

While make_L8(ExpressaoLogica p1, BlocoComando p2)
{
    While tmp = (While) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L8!\n");
        exit(1);
    }
    tmp->kind = is_L8;
    tmp->u.l8_.expressaologica_ = p1;
    tmp->u.l8_.blococomando_ = p2;
    return tmp;
}

/********************   For1    ********************/

For make_For1(Atribuicao p1, Integer p2, BlocoComando p3)
{
    For tmp = (For) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating For1!\n");
        exit(1);
    }
    tmp->kind = is_For1;
    tmp->u.for1_.atribuicao_ = p1;
    tmp->u.for1_.integer_ = p2;
    tmp->u.for1_.blococomando_ = p3;
    return tmp;
}

/********************   For2    ********************/

For make_For2(Atribuicao p1, Ident p2, BlocoComando p3)
{
    For tmp = (For) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating For2!\n");
        exit(1);
    }
    tmp->kind = is_For2;
    tmp->u.for2_.atribuicao_ = p1;
    tmp->u.for2_.ident_ = p2;
    tmp->u.for2_.blococomando_ = p3;
    return tmp;
}

/********************   L9    ********************/

Goto make_L9(Ident p1)
{
    Goto tmp = (Goto) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L9!\n");
        exit(1);
    }
    tmp->kind = is_L9;
    tmp->u.l9_.ident_ = p1;
    return tmp;
}

/********************   L10    ********************/

Rotulo make_L10(Ident p1, RegraComando p2)
{
    Rotulo tmp = (Rotulo) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L10!\n");
        exit(1);
    }
    tmp->kind = is_L10;
    tmp->u.l10_.ident_ = p1;
    tmp->u.l10_.regracomando_ = p2;
    return tmp;
}

/********************   L11    ********************/

Struct make_L11(DefinicaoCampoStruct p1)
{
    Struct tmp = (Struct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L11!\n");
        exit(1);
    }
    tmp->kind = is_L11;
    tmp->u.l11_.definicaocampostruct_ = p1;
    return tmp;
}

/********************   DefinicaoCampoStruct1    ********************/

DefinicaoCampoStruct make_DefinicaoCampoStruct1(Ident p1, RegraTipo p2)
{
    DefinicaoCampoStruct tmp = (DefinicaoCampoStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating DefinicaoCampoStruct1!\n");
        exit(1);
    }
    tmp->kind = is_DefinicaoCampoStruct1;
    tmp->u.definicaocampostruct1_.ident_ = p1;
    tmp->u.definicaocampostruct1_.regratipo_ = p2;
    return tmp;
}

/********************   DefinicaoCampoStruct2    ********************/

DefinicaoCampoStruct make_DefinicaoCampoStruct2(Ident p1, RegraTipo p2, DefinicaoCampoStruct p3)
{
    DefinicaoCampoStruct tmp = (DefinicaoCampoStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating DefinicaoCampoStruct2!\n");
        exit(1);
    }
    tmp->kind = is_DefinicaoCampoStruct2;
    tmp->u.definicaocampostruct2_.ident_ = p1;
    tmp->u.definicaocampostruct2_.regratipo_ = p2;
    tmp->u.definicaocampostruct2_.definicaocampostruct_ = p3;
    return tmp;
}

/********************   AtribuicaoStruct1    ********************/

AtribuicaoStruct make_AtribuicaoStruct1(Ident p1, Ident p2, Valor p3)
{
    AtribuicaoStruct tmp = (AtribuicaoStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoStruct1!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoStruct1;
    tmp->u.atribuicaostruct1_.ident_1 = p1;
    tmp->u.atribuicaostruct1_.ident_2 = p2;
    tmp->u.atribuicaostruct1_.valor_ = p3;
    return tmp;
}

/********************   AtribuicaoStruct2    ********************/

AtribuicaoStruct make_AtribuicaoStruct2(Ident p1, Ident p2, Valor p3, AtribuicaoStruct p4)
{
    AtribuicaoStruct tmp = (AtribuicaoStruct) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AtribuicaoStruct2!\n");
        exit(1);
    }
    tmp->kind = is_AtribuicaoStruct2;
    tmp->u.atribuicaostruct2_.ident_1 = p1;
    tmp->u.atribuicaostruct2_.ident_2 = p2;
    tmp->u.atribuicaostruct2_.valor_ = p3;
    tmp->u.atribuicaostruct2_.atribuicaostruct_ = p4;
    return tmp;
}

/********************   OperadorRelacional1    ********************/

OperadorRelacional make_OperadorRelacional1()
{
    OperadorRelacional tmp = (OperadorRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorRelacional1!\n");
        exit(1);
    }
    tmp->kind = is_OperadorRelacional1;
    return tmp;
}

/********************   OperadorRelacional2    ********************/

OperadorRelacional make_OperadorRelacional2()
{
    OperadorRelacional tmp = (OperadorRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorRelacional2!\n");
        exit(1);
    }
    tmp->kind = is_OperadorRelacional2;
    return tmp;
}

/********************   OperadorRelacional3    ********************/

OperadorRelacional make_OperadorRelacional3()
{
    OperadorRelacional tmp = (OperadorRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorRelacional3!\n");
        exit(1);
    }
    tmp->kind = is_OperadorRelacional3;
    return tmp;
}

/********************   OperadorRelacional4    ********************/

OperadorRelacional make_OperadorRelacional4()
{
    OperadorRelacional tmp = (OperadorRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorRelacional4!\n");
        exit(1);
    }
    tmp->kind = is_OperadorRelacional4;
    return tmp;
}

/********************   OperadorRelacional5    ********************/

OperadorRelacional make_OperadorRelacional5()
{
    OperadorRelacional tmp = (OperadorRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorRelacional5!\n");
        exit(1);
    }
    tmp->kind = is_OperadorRelacional5;
    return tmp;
}

/********************   OperadorRelacional6    ********************/

OperadorRelacional make_OperadorRelacional6()
{
    OperadorRelacional tmp = (OperadorRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorRelacional6!\n");
        exit(1);
    }
    tmp->kind = is_OperadorRelacional6;
    return tmp;
}

/********************   OperadorLogico1    ********************/

OperadorLogico make_OperadorLogico1()
{
    OperadorLogico tmp = (OperadorLogico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorLogico1!\n");
        exit(1);
    }
    tmp->kind = is_OperadorLogico1;
    return tmp;
}

/********************   OperadorLogico2    ********************/

OperadorLogico make_OperadorLogico2()
{
    OperadorLogico tmp = (OperadorLogico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorLogico2!\n");
        exit(1);
    }
    tmp->kind = is_OperadorLogico2;
    return tmp;
}

/********************   OperadorLogico3    ********************/

OperadorLogico make_OperadorLogico3()
{
    OperadorLogico tmp = (OperadorLogico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorLogico3!\n");
        exit(1);
    }
    tmp->kind = is_OperadorLogico3;
    return tmp;
}

/********************   OperadorLogico4    ********************/

OperadorLogico make_OperadorLogico4()
{
    OperadorLogico tmp = (OperadorLogico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorLogico4!\n");
        exit(1);
    }
    tmp->kind = is_OperadorLogico4;
    return tmp;
}

/********************   OperadorAritmetico1    ********************/

OperadorAritmetico make_OperadorAritmetico1()
{
    OperadorAritmetico tmp = (OperadorAritmetico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorAritmetico1!\n");
        exit(1);
    }
    tmp->kind = is_OperadorAritmetico1;
    return tmp;
}

/********************   OperadorAritmetico2    ********************/

OperadorAritmetico make_OperadorAritmetico2()
{
    OperadorAritmetico tmp = (OperadorAritmetico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorAritmetico2!\n");
        exit(1);
    }
    tmp->kind = is_OperadorAritmetico2;
    return tmp;
}

/********************   OperadorAritmetico3    ********************/

OperadorAritmetico make_OperadorAritmetico3()
{
    OperadorAritmetico tmp = (OperadorAritmetico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorAritmetico3!\n");
        exit(1);
    }
    tmp->kind = is_OperadorAritmetico3;
    return tmp;
}

/********************   OperadorAritmetico4    ********************/

OperadorAritmetico make_OperadorAritmetico4()
{
    OperadorAritmetico tmp = (OperadorAritmetico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperadorAritmetico4!\n");
        exit(1);
    }
    tmp->kind = is_OperadorAritmetico4;
    return tmp;
}

/********************   L12    ********************/

Case make_L12(Seletor p1, RegraSeletor p2)
{
    Case tmp = (Case) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L12!\n");
        exit(1);
    }
    tmp->kind = is_L12;
    tmp->u.l12_.seletor_ = p1;
    tmp->u.l12_.regraseletor_ = p2;
    return tmp;
}

/********************   RegraSeletor1    ********************/

RegraSeletor make_RegraSeletor1(Seletor p1, Comando p2)
{
    RegraSeletor tmp = (RegraSeletor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraSeletor1!\n");
        exit(1);
    }
    tmp->kind = is_RegraSeletor1;
    tmp->u.regraseletor1_.seletor_ = p1;
    tmp->u.regraseletor1_.comando_ = p2;
    return tmp;
}

/********************   RegraSeletor2    ********************/

RegraSeletor make_RegraSeletor2(Seletor p1, Comando p2, RegraSeletor p3)
{
    RegraSeletor tmp = (RegraSeletor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraSeletor2!\n");
        exit(1);
    }
    tmp->kind = is_RegraSeletor2;
    tmp->u.regraseletor2_.seletor_ = p1;
    tmp->u.regraseletor2_.comando_ = p2;
    tmp->u.regraseletor2_.regraseletor_ = p3;
    return tmp;
}

/********************   SeletorInteger    ********************/

Seletor make_SeletorInteger(Integer p1)
{
    Seletor tmp = (Seletor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SeletorInteger!\n");
        exit(1);
    }
    tmp->kind = is_SeletorInteger;
    tmp->u.seletorinteger_.integer_ = p1;
    return tmp;
}

/********************   SeletorChar    ********************/

Seletor make_SeletorChar(Char p1)
{
    Seletor tmp = (Seletor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SeletorChar!\n");
        exit(1);
    }
    tmp->kind = is_SeletorChar;
    tmp->u.seletorchar_.char_ = p1;
    return tmp;
}

/********************   SeletorIdent    ********************/

Seletor make_SeletorIdent(Ident p1)
{
    Seletor tmp = (Seletor) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SeletorIdent!\n");
        exit(1);
    }
    tmp->kind = is_SeletorIdent;
    tmp->u.seletorident_.ident_ = p1;
    return tmp;
}

/********************   L13    ********************/

Funcao make_L13(Ident p1, RegraBlocoVar p2, RegraTipo p3, BlocoVar p4, BlocoComando p5)
{
    Funcao tmp = (Funcao) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L13!\n");
        exit(1);
    }
    tmp->kind = is_L13;
    tmp->u.l13_.ident_ = p1;
    tmp->u.l13_.regrablocovar_ = p2;
    tmp->u.l13_.regratipo_ = p3;
    tmp->u.l13_.blocovar_ = p4;
    tmp->u.l13_.blococomando_ = p5;
    return tmp;
}

/********************   Procedimento1    ********************/

Procedimento make_Procedimento1(Ident p1, RegraBlocoVar p2, BlocoVar p3, BlocoComando p4)
{
    Procedimento tmp = (Procedimento) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Procedimento1!\n");
        exit(1);
    }
    tmp->kind = is_Procedimento1;
    tmp->u.procedimento1_.ident_ = p1;
    tmp->u.procedimento1_.regrablocovar_ = p2;
    tmp->u.procedimento1_.blocovar_ = p3;
    tmp->u.procedimento1_.blococomando_ = p4;
    return tmp;
}

/********************   Procedimento2    ********************/

Procedimento make_Procedimento2(Ident p1, BlocoVar p2, BlocoComando p3)
{
    Procedimento tmp = (Procedimento) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Procedimento2!\n");
        exit(1);
    }
    tmp->kind = is_Procedimento2;
    tmp->u.procedimento2_.ident_ = p1;
    tmp->u.procedimento2_.blocovar_ = p2;
    tmp->u.procedimento2_.blococomando_ = p3;
    return tmp;
}

/********************   L14    ********************/

ExpressaoAritmetica make_L14(Operando p1, RegraAritmetica p2)
{
    ExpressaoAritmetica tmp = (ExpressaoAritmetica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating L14!\n");
        exit(1);
    }
    tmp->kind = is_L14;
    tmp->u.l14_.operando_ = p1;
    tmp->u.l14_.regraaritmetica_ = p2;
    return tmp;
}

/********************   OperandoInteger    ********************/

Operando make_OperandoInteger(Integer p1)
{
    Operando tmp = (Operando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperandoInteger!\n");
        exit(1);
    }
    tmp->kind = is_OperandoInteger;
    tmp->u.operandointeger_.integer_ = p1;
    return tmp;
}

/********************   OperandoDouble    ********************/

Operando make_OperandoDouble(Double p1)
{
    Operando tmp = (Operando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperandoDouble!\n");
        exit(1);
    }
    tmp->kind = is_OperandoDouble;
    tmp->u.operandodouble_.double_ = p1;
    return tmp;
}

/********************   OperandoIdent    ********************/

Operando make_OperandoIdent(Ident p1)
{
    Operando tmp = (Operando) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OperandoIdent!\n");
        exit(1);
    }
    tmp->kind = is_OperandoIdent;
    tmp->u.operandoident_.ident_ = p1;
    return tmp;
}

/********************   RegraAritmetica1    ********************/

RegraAritmetica make_RegraAritmetica1(OperadorAritmetico p1, Operando p2)
{
    RegraAritmetica tmp = (RegraAritmetica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraAritmetica1!\n");
        exit(1);
    }
    tmp->kind = is_RegraAritmetica1;
    tmp->u.regraaritmetica1_.operadoraritmetico_ = p1;
    tmp->u.regraaritmetica1_.operando_ = p2;
    return tmp;
}

/********************   RegraAritmetica2    ********************/

RegraAritmetica make_RegraAritmetica2(OperadorAritmetico p1, Operando p2, RegraAritmetica p3)
{
    RegraAritmetica tmp = (RegraAritmetica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraAritmetica2!\n");
        exit(1);
    }
    tmp->kind = is_RegraAritmetica2;
    tmp->u.regraaritmetica2_.operadoraritmetico_ = p1;
    tmp->u.regraaritmetica2_.operando_ = p2;
    tmp->u.regraaritmetica2_.regraaritmetica_ = p3;
    return tmp;
}

/********************   ExpressaoRelacional1    ********************/

ExpressaoRelacional make_ExpressaoRelacional1(Operando p1, RegraRelacional p2)
{
    ExpressaoRelacional tmp = (ExpressaoRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoRelacional1!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoRelacional1;
    tmp->u.expressaorelacional1_.operando_ = p1;
    tmp->u.expressaorelacional1_.regrarelacional_ = p2;
    return tmp;
}

/********************   ExpressaoRelacional2    ********************/

ExpressaoRelacional make_ExpressaoRelacional2(ExpressaoAritmetica p1, RegraRelacional p2)
{
    ExpressaoRelacional tmp = (ExpressaoRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoRelacional2!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoRelacional2;
    tmp->u.expressaorelacional2_.expressaoaritmetica_ = p1;
    tmp->u.expressaorelacional2_.regrarelacional_ = p2;
    return tmp;
}

/********************   RegraRelacional1    ********************/

RegraRelacional make_RegraRelacional1(OperadorRelacional p1, Operando p2)
{
    RegraRelacional tmp = (RegraRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraRelacional1!\n");
        exit(1);
    }
    tmp->kind = is_RegraRelacional1;
    tmp->u.regrarelacional1_.operadorrelacional_ = p1;
    tmp->u.regrarelacional1_.operando_ = p2;
    return tmp;
}

/********************   RegraRelacional2    ********************/

RegraRelacional make_RegraRelacional2(OperadorRelacional p1, ExpressaoAritmetica p2)
{
    RegraRelacional tmp = (RegraRelacional) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraRelacional2!\n");
        exit(1);
    }
    tmp->kind = is_RegraRelacional2;
    tmp->u.regrarelacional2_.operadorrelacional_ = p1;
    tmp->u.regrarelacional2_.expressaoaritmetica_ = p2;
    return tmp;
}

/********************   ExpressaoLogica_falso    ********************/

ExpressaoLogica make_ExpressaoLogica_falso()
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica_falso!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica_falso;
    return tmp;
}

/********************   ExpressaoLogica_verdadeiro    ********************/

ExpressaoLogica make_ExpressaoLogica_verdadeiro()
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica_verdadeiro!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica_verdadeiro;
    return tmp;
}

/********************   ExpressaoLogicaExpressaoRelacional    ********************/

ExpressaoLogica make_ExpressaoLogicaExpressaoRelacional(ExpressaoRelacional p1)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogicaExpressaoRelacional!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogicaExpressaoRelacional;
    tmp->u.expressaologicaexpressaorelacional_.expressaorelacional_ = p1;
    return tmp;
}

/********************   ExpressaoLogica1    ********************/

ExpressaoLogica make_ExpressaoLogica1(RegraLogico p1)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica1!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica1;
    tmp->u.expressaologica1_.regralogico_ = p1;
    return tmp;
}

/********************   ExpressaoLogica2    ********************/

ExpressaoLogica make_ExpressaoLogica2(RegraLogico p1)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica2!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica2;
    tmp->u.expressaologica2_.regralogico_ = p1;
    return tmp;
}

/********************   ExpressaoLogica3    ********************/

ExpressaoLogica make_ExpressaoLogica3(ExpressaoRelacional p1, RegraLogico p2)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica3!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica3;
    tmp->u.expressaologica3_.expressaorelacional_ = p1;
    tmp->u.expressaologica3_.regralogico_ = p2;
    return tmp;
}

/********************   ExpressaoLogica4    ********************/

ExpressaoLogica make_ExpressaoLogica4(OperadorLogico p1, ExpressaoLogica p2)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica4!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica4;
    tmp->u.expressaologica4_.operadorlogico_ = p1;
    tmp->u.expressaologica4_.expressaologica_ = p2;
    return tmp;
}

/********************   ExpressaoLogica5    ********************/

ExpressaoLogica make_ExpressaoLogica5(OperadorLogico p1, ExpressaoLogica p2, RegraLogico p3)
{
    ExpressaoLogica tmp = (ExpressaoLogica) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExpressaoLogica5!\n");
        exit(1);
    }
    tmp->kind = is_ExpressaoLogica5;
    tmp->u.expressaologica5_.operadorlogico_ = p1;
    tmp->u.expressaologica5_.expressaologica_ = p2;
    tmp->u.expressaologica5_.regralogico_ = p3;
    return tmp;
}

/********************   RegraLogico1    ********************/

RegraLogico make_RegraLogico1(OperadorLogico p1, ExpressaoLogica p2)
{
    RegraLogico tmp = (RegraLogico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraLogico1!\n");
        exit(1);
    }
    tmp->kind = is_RegraLogico1;
    tmp->u.regralogico1_.operadorlogico_ = p1;
    tmp->u.regralogico1_.expressaologica_ = p2;
    return tmp;
}

/********************   RegraLogico2    ********************/

RegraLogico make_RegraLogico2(OperadorLogico p1, ExpressaoLogica p2, RegraLogico p3)
{
    RegraLogico tmp = (RegraLogico) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RegraLogico2!\n");
        exit(1);
    }
    tmp->kind = is_RegraLogico2;
    tmp->u.regralogico2_.operadorlogico_ = p1;
    tmp->u.regralogico2_.expressaologica_ = p2;
    tmp->u.regralogico2_.regralogico_ = p3;
    return tmp;
}

/***************************   Cloning   ******************************/

Entry clone_Entry(Entry p)
{
  switch(p->kind)
  {
  case is_L1:
    return make_L1
      ( strdup(p->u.l1_.ident_)
      , clone_BlocoConstante(p->u.l1_.blococonstante_)
      , clone_BlocoTipo(p->u.l1_.blocotipo_)
      , clone_BlocoVar(p->u.l1_.blocovar_)
      , clone_BlocoComando(p->u.l1_.blococomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Entry!\n");
    exit(1);
  }
}

BlocoConstante clone_BlocoConstante(BlocoConstante p)
{
  switch(p->kind)
  {
  case is_BlocoConstante1:
    return make_BlocoConstante1 (clone_RegraBlocoConstante(p->u.blococonstante1_.regrablococonstante_));

  case is_BlocoConstante2:
    return make_BlocoConstante2 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoConstante!\n");
    exit(1);
  }
}

RegraBlocoConstante clone_RegraBlocoConstante(RegraBlocoConstante p)
{
  switch(p->kind)
  {
  case is_RegraBlocoConstante1:
    return make_RegraBlocoConstante1
      ( strdup(p->u.regrablococonstante1_.ident_)
      , clone_Valor(p->u.regrablococonstante1_.valor_)
      );

  case is_RegraBlocoConstante2:
    return make_RegraBlocoConstante2
      ( strdup(p->u.regrablococonstante2_.ident_)
      , clone_Valor(p->u.regrablococonstante2_.valor_)
      , clone_RegraBlocoConstante(p->u.regrablococonstante2_.regrablococonstante_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraBlocoConstante!\n");
    exit(1);
  }
}

BlocoTipo clone_BlocoTipo(BlocoTipo p)
{
  switch(p->kind)
  {
  case is_BlocoTipo1:
    return make_BlocoTipo1 (clone_RegraBlocoTipo(p->u.blocotipo1_.regrablocotipo_));

  case is_BlocoTipo_:
    return make_BlocoTipo_ ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoTipo!\n");
    exit(1);
  }
}

RegraBlocoTipo clone_RegraBlocoTipo(RegraBlocoTipo p)
{
  switch(p->kind)
  {
  case is_RegraBlocoTipo1:
    return make_RegraBlocoTipo1
      ( strdup(p->u.regrablocotipo1_.ident_)
      , clone_RegraTipo(p->u.regrablocotipo1_.regratipo_)
      );

  case is_RegraBlocoTipo2:
    return make_RegraBlocoTipo2
      ( strdup(p->u.regrablocotipo2_.ident_)
      , clone_RegraTipo(p->u.regrablocotipo2_.regratipo_)
      , clone_RegraBlocoTipo(p->u.regrablocotipo2_.regrablocotipo_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraBlocoTipo!\n");
    exit(1);
  }
}

BlocoVar clone_BlocoVar(BlocoVar p)
{
  switch(p->kind)
  {
  case is_BlocoVar1:
    return make_BlocoVar1 (clone_RegraBlocoVar(p->u.blocovar1_.regrablocovar_));

  case is_BlocoVar2:
    return make_BlocoVar2 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoVar!\n");
    exit(1);
  }
}

RegraBlocoVar clone_RegraBlocoVar(RegraBlocoVar p)
{
  switch(p->kind)
  {
  case is_RegraBlocoVar1:
    return make_RegraBlocoVar1
      ( strdup(p->u.regrablocovar1_.ident_)
      , clone_RegraTipo(p->u.regrablocovar1_.regratipo_)
      );

  case is_RegraBlocoVar2:
    return make_RegraBlocoVar2
      ( strdup(p->u.regrablocovar2_.ident_)
      , clone_RegraTipo(p->u.regrablocovar2_.regratipo_)
      , clone_RegraBlocoVar(p->u.regrablocovar2_.regrablocovar_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraBlocoVar!\n");
    exit(1);
  }
}

BlocoComando clone_BlocoComando(BlocoComando p)
{
  switch(p->kind)
  {
  case is_BlocoComando1:
    return make_BlocoComando1 (clone_RegraComando(p->u.blococomando1_.regracomando_));

  case is_BlocoComando2:
    return make_BlocoComando2 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning BlocoComando!\n");
    exit(1);
  }
}

RegraComando clone_RegraComando(RegraComando p)
{
  switch(p->kind)
  {
  case is_RegraComando1:
    return make_RegraComando1 (clone_Comando(p->u.regracomando1_.comando_));

  case is_RegraComando2:
    return make_RegraComando2
      ( clone_Comando(p->u.regracomando2_.comando_)
      , clone_RegraComando(p->u.regracomando2_.regracomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraComando!\n");
    exit(1);
  }
}

Comando clone_Comando(Comando p)
{
  switch(p->kind)
  {
  case is_ComandoAtribuicao:
    return make_ComandoAtribuicao (clone_Atribuicao(p->u.comandoatribuicao_.atribuicao_));

  case is_ComandoIf:
    return make_ComandoIf (clone_If(p->u.comandoif_.if_));

  case is_ComandoWhile:
    return make_ComandoWhile (clone_While(p->u.comandowhile_.while_));

  case is_ComandoFor:
    return make_ComandoFor (clone_For(p->u.comandofor_.for_));

  case is_ComandoGoto:
    return make_ComandoGoto (clone_Goto(p->u.comandogoto_.goto_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Comando!\n");
    exit(1);
  }
}

Atribuicao clone_Atribuicao(Atribuicao p)
{
  switch(p->kind)
  {
  case is_Atribuicao1:
    return make_Atribuicao1
      ( strdup(p->u.atribuicao1_.ident_)
      , clone_Valor(p->u.atribuicao1_.valor_)
      );

  case is_Atribuicao2:
    return make_Atribuicao2
      ( strdup(p->u.atribuicao2_.ident_)
      , clone_SubEscrito(p->u.atribuicao2_.subescrito_)
      , clone_Valor(p->u.atribuicao2_.valor_)
      );

  case is_Atribuicao3:
    return make_Atribuicao3
      ( strdup(p->u.atribuicao3_.ident_)
      , clone_Valor(p->u.atribuicao3_.valor_)
      );

  case is_AtribuicaoAtribuicaoStruct:
    return make_AtribuicaoAtribuicaoStruct (clone_AtribuicaoStruct(p->u.atribuicaoatribuicaostruct_.atribuicaostruct_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Atribuicao!\n");
    exit(1);
  }
}

SubEscrito clone_SubEscrito(SubEscrito p)
{
  switch(p->kind)
  {
  case is_SubEscritoIdent:
    return make_SubEscritoIdent (strdup(p->u.subescritoident_.ident_));

  case is_SubEscritoInteger:
    return make_SubEscritoInteger (p->u.subescritointeger_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning SubEscrito!\n");
    exit(1);
  }
}

RegraTipo clone_RegraTipo(RegraTipo p)
{
  switch(p->kind)
  {
  case is_RegraTipoTipoPrimitivo:
    return make_RegraTipoTipoPrimitivo (clone_TipoPrimitivo(p->u.regratipotipoprimitivo_.tipoprimitivo_));

  case is_RegraTipoTipoDerivado:
    return make_RegraTipoTipoDerivado (clone_TipoDerivado(p->u.regratipotipoderivado_.tipoderivado_));

  case is_RegraTipoIdent:
    return make_RegraTipoIdent (strdup(p->u.regratipoident_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraTipo!\n");
    exit(1);
  }
}

TipoPrimitivo clone_TipoPrimitivo(TipoPrimitivo p)
{
  switch(p->kind)
  {
  case is_TipoPrimitivo_int:
    return make_TipoPrimitivo_int ();

  case is_TipoPrimitivo_real:
    return make_TipoPrimitivo_real ();

  case is_TipoPrimitivo_char:
    return make_TipoPrimitivo_char ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning TipoPrimitivo!\n");
    exit(1);
  }
}

Valor clone_Valor(Valor p)
{
  switch(p->kind)
  {
  case is_ValorInteger:
    return make_ValorInteger (p->u.valorinteger_.integer_);

  case is_ValorDouble:
    return make_ValorDouble (p->u.valordouble_.double_);

  case is_ValorChar:
    return make_ValorChar (p->u.valorchar_.char_);

  case is_ValorString:
    return make_ValorString (strdup(p->u.valorstring_.string_));

  case is_ValorExpressaoAritmetica:
    return make_ValorExpressaoAritmetica (clone_ExpressaoAritmetica(p->u.valorexpressaoaritmetica_.expressaoaritmetica_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Valor!\n");
    exit(1);
  }
}

TipoDerivado clone_TipoDerivado(TipoDerivado p)
{
  switch(p->kind)
  {
  case is_TipoDerivadoPonteiro:
    return make_TipoDerivadoPonteiro (clone_Ponteiro(p->u.tipoderivadoponteiro_.ponteiro_));

  case is_TipoDerivadoVetor:
    return make_TipoDerivadoVetor (clone_Vetor(p->u.tipoderivadovetor_.vetor_));

  case is_TipoDerivadoStruct:
    return make_TipoDerivadoStruct (clone_Struct(p->u.tipoderivadostruct_.struct_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning TipoDerivado!\n");
    exit(1);
  }
}

Ponteiro clone_Ponteiro(Ponteiro p)
{
  switch(p->kind)
  {
  case is_Ponteiro1:
    return make_Ponteiro1 (clone_TipoPrimitivo(p->u.ponteiro1_.tipoprimitivo_));

  case is_Ponteiro2:
    return make_Ponteiro2 (clone_TipoDerivado(p->u.ponteiro2_.tipoderivado_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Ponteiro!\n");
    exit(1);
  }
}

Vetor clone_Vetor(Vetor p)
{
  switch(p->kind)
  {
  case is_L7:
    return make_L7
      ( p->u.l7_.integer_1
      , p->u.l7_.integer_2
      , clone_TipoPrimitivo(p->u.l7_.tipoprimitivo_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Vetor!\n");
    exit(1);
  }
}

If clone_If(If p)
{
  switch(p->kind)
  {
  case is_If1:
    return make_If1
      ( clone_ExpressaoLogica(p->u.if1_.expressaologica_)
      , clone_BlocoComando(p->u.if1_.blococomando_)
      );

  case is_If2:
    return make_If2
      ( clone_ExpressaoLogica(p->u.if2_.expressaologica_)
      , clone_BlocoComando(p->u.if2_.blococomando_1)
      , clone_BlocoComando(p->u.if2_.blococomando_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning If!\n");
    exit(1);
  }
}

While clone_While(While p)
{
  switch(p->kind)
  {
  case is_L8:
    return make_L8
      ( clone_ExpressaoLogica(p->u.l8_.expressaologica_)
      , clone_BlocoComando(p->u.l8_.blococomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning While!\n");
    exit(1);
  }
}

For clone_For(For p)
{
  switch(p->kind)
  {
  case is_For1:
    return make_For1
      ( clone_Atribuicao(p->u.for1_.atribuicao_)
      , p->u.for1_.integer_
      , clone_BlocoComando(p->u.for1_.blococomando_)
      );

  case is_For2:
    return make_For2
      ( clone_Atribuicao(p->u.for2_.atribuicao_)
      , strdup(p->u.for2_.ident_)
      , clone_BlocoComando(p->u.for2_.blococomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning For!\n");
    exit(1);
  }
}

Goto clone_Goto(Goto p)
{
  switch(p->kind)
  {
  case is_L9:
    return make_L9 (strdup(p->u.l9_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Goto!\n");
    exit(1);
  }
}

Rotulo clone_Rotulo(Rotulo p)
{
  switch(p->kind)
  {
  case is_L10:
    return make_L10
      ( strdup(p->u.l10_.ident_)
      , clone_RegraComando(p->u.l10_.regracomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Rotulo!\n");
    exit(1);
  }
}

Struct clone_Struct(Struct p)
{
  switch(p->kind)
  {
  case is_L11:
    return make_L11 (clone_DefinicaoCampoStruct(p->u.l11_.definicaocampostruct_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Struct!\n");
    exit(1);
  }
}

DefinicaoCampoStruct clone_DefinicaoCampoStruct(DefinicaoCampoStruct p)
{
  switch(p->kind)
  {
  case is_DefinicaoCampoStruct1:
    return make_DefinicaoCampoStruct1
      ( strdup(p->u.definicaocampostruct1_.ident_)
      , clone_RegraTipo(p->u.definicaocampostruct1_.regratipo_)
      );

  case is_DefinicaoCampoStruct2:
    return make_DefinicaoCampoStruct2
      ( strdup(p->u.definicaocampostruct2_.ident_)
      , clone_RegraTipo(p->u.definicaocampostruct2_.regratipo_)
      , clone_DefinicaoCampoStruct(p->u.definicaocampostruct2_.definicaocampostruct_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning DefinicaoCampoStruct!\n");
    exit(1);
  }
}

AtribuicaoStruct clone_AtribuicaoStruct(AtribuicaoStruct p)
{
  switch(p->kind)
  {
  case is_AtribuicaoStruct1:
    return make_AtribuicaoStruct1
      ( strdup(p->u.atribuicaostruct1_.ident_1)
      , strdup(p->u.atribuicaostruct1_.ident_2)
      , clone_Valor(p->u.atribuicaostruct1_.valor_)
      );

  case is_AtribuicaoStruct2:
    return make_AtribuicaoStruct2
      ( strdup(p->u.atribuicaostruct2_.ident_1)
      , strdup(p->u.atribuicaostruct2_.ident_2)
      , clone_Valor(p->u.atribuicaostruct2_.valor_)
      , clone_AtribuicaoStruct(p->u.atribuicaostruct2_.atribuicaostruct_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning AtribuicaoStruct!\n");
    exit(1);
  }
}

OperadorRelacional clone_OperadorRelacional(OperadorRelacional p)
{
  switch(p->kind)
  {
  case is_OperadorRelacional1:
    return make_OperadorRelacional1 ();

  case is_OperadorRelacional2:
    return make_OperadorRelacional2 ();

  case is_OperadorRelacional3:
    return make_OperadorRelacional3 ();

  case is_OperadorRelacional4:
    return make_OperadorRelacional4 ();

  case is_OperadorRelacional5:
    return make_OperadorRelacional5 ();

  case is_OperadorRelacional6:
    return make_OperadorRelacional6 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OperadorRelacional!\n");
    exit(1);
  }
}

OperadorLogico clone_OperadorLogico(OperadorLogico p)
{
  switch(p->kind)
  {
  case is_OperadorLogico1:
    return make_OperadorLogico1 ();

  case is_OperadorLogico2:
    return make_OperadorLogico2 ();

  case is_OperadorLogico3:
    return make_OperadorLogico3 ();

  case is_OperadorLogico4:
    return make_OperadorLogico4 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OperadorLogico!\n");
    exit(1);
  }
}

OperadorAritmetico clone_OperadorAritmetico(OperadorAritmetico p)
{
  switch(p->kind)
  {
  case is_OperadorAritmetico1:
    return make_OperadorAritmetico1 ();

  case is_OperadorAritmetico2:
    return make_OperadorAritmetico2 ();

  case is_OperadorAritmetico3:
    return make_OperadorAritmetico3 ();

  case is_OperadorAritmetico4:
    return make_OperadorAritmetico4 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OperadorAritmetico!\n");
    exit(1);
  }
}

Case clone_Case(Case p)
{
  switch(p->kind)
  {
  case is_L12:
    return make_L12
      ( clone_Seletor(p->u.l12_.seletor_)
      , clone_RegraSeletor(p->u.l12_.regraseletor_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Case!\n");
    exit(1);
  }
}

RegraSeletor clone_RegraSeletor(RegraSeletor p)
{
  switch(p->kind)
  {
  case is_RegraSeletor1:
    return make_RegraSeletor1
      ( clone_Seletor(p->u.regraseletor1_.seletor_)
      , clone_Comando(p->u.regraseletor1_.comando_)
      );

  case is_RegraSeletor2:
    return make_RegraSeletor2
      ( clone_Seletor(p->u.regraseletor2_.seletor_)
      , clone_Comando(p->u.regraseletor2_.comando_)
      , clone_RegraSeletor(p->u.regraseletor2_.regraseletor_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraSeletor!\n");
    exit(1);
  }
}

Seletor clone_Seletor(Seletor p)
{
  switch(p->kind)
  {
  case is_SeletorInteger:
    return make_SeletorInteger (p->u.seletorinteger_.integer_);

  case is_SeletorChar:
    return make_SeletorChar (p->u.seletorchar_.char_);

  case is_SeletorIdent:
    return make_SeletorIdent (strdup(p->u.seletorident_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Seletor!\n");
    exit(1);
  }
}

Funcao clone_Funcao(Funcao p)
{
  switch(p->kind)
  {
  case is_L13:
    return make_L13
      ( strdup(p->u.l13_.ident_)
      , clone_RegraBlocoVar(p->u.l13_.regrablocovar_)
      , clone_RegraTipo(p->u.l13_.regratipo_)
      , clone_BlocoVar(p->u.l13_.blocovar_)
      , clone_BlocoComando(p->u.l13_.blococomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Funcao!\n");
    exit(1);
  }
}

Procedimento clone_Procedimento(Procedimento p)
{
  switch(p->kind)
  {
  case is_Procedimento1:
    return make_Procedimento1
      ( strdup(p->u.procedimento1_.ident_)
      , clone_RegraBlocoVar(p->u.procedimento1_.regrablocovar_)
      , clone_BlocoVar(p->u.procedimento1_.blocovar_)
      , clone_BlocoComando(p->u.procedimento1_.blococomando_)
      );

  case is_Procedimento2:
    return make_Procedimento2
      ( strdup(p->u.procedimento2_.ident_)
      , clone_BlocoVar(p->u.procedimento2_.blocovar_)
      , clone_BlocoComando(p->u.procedimento2_.blococomando_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Procedimento!\n");
    exit(1);
  }
}

ExpressaoAritmetica clone_ExpressaoAritmetica(ExpressaoAritmetica p)
{
  switch(p->kind)
  {
  case is_L14:
    return make_L14
      ( clone_Operando(p->u.l14_.operando_)
      , clone_RegraAritmetica(p->u.l14_.regraaritmetica_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ExpressaoAritmetica!\n");
    exit(1);
  }
}

Operando clone_Operando(Operando p)
{
  switch(p->kind)
  {
  case is_OperandoInteger:
    return make_OperandoInteger (p->u.operandointeger_.integer_);

  case is_OperandoDouble:
    return make_OperandoDouble (p->u.operandodouble_.double_);

  case is_OperandoIdent:
    return make_OperandoIdent (strdup(p->u.operandoident_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Operando!\n");
    exit(1);
  }
}

RegraAritmetica clone_RegraAritmetica(RegraAritmetica p)
{
  switch(p->kind)
  {
  case is_RegraAritmetica1:
    return make_RegraAritmetica1
      ( clone_OperadorAritmetico(p->u.regraaritmetica1_.operadoraritmetico_)
      , clone_Operando(p->u.regraaritmetica1_.operando_)
      );

  case is_RegraAritmetica2:
    return make_RegraAritmetica2
      ( clone_OperadorAritmetico(p->u.regraaritmetica2_.operadoraritmetico_)
      , clone_Operando(p->u.regraaritmetica2_.operando_)
      , clone_RegraAritmetica(p->u.regraaritmetica2_.regraaritmetica_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraAritmetica!\n");
    exit(1);
  }
}

ExpressaoRelacional clone_ExpressaoRelacional(ExpressaoRelacional p)
{
  switch(p->kind)
  {
  case is_ExpressaoRelacional1:
    return make_ExpressaoRelacional1
      ( clone_Operando(p->u.expressaorelacional1_.operando_)
      , clone_RegraRelacional(p->u.expressaorelacional1_.regrarelacional_)
      );

  case is_ExpressaoRelacional2:
    return make_ExpressaoRelacional2
      ( clone_ExpressaoAritmetica(p->u.expressaorelacional2_.expressaoaritmetica_)
      , clone_RegraRelacional(p->u.expressaorelacional2_.regrarelacional_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ExpressaoRelacional!\n");
    exit(1);
  }
}

RegraRelacional clone_RegraRelacional(RegraRelacional p)
{
  switch(p->kind)
  {
  case is_RegraRelacional1:
    return make_RegraRelacional1
      ( clone_OperadorRelacional(p->u.regrarelacional1_.operadorrelacional_)
      , clone_Operando(p->u.regrarelacional1_.operando_)
      );

  case is_RegraRelacional2:
    return make_RegraRelacional2
      ( clone_OperadorRelacional(p->u.regrarelacional2_.operadorrelacional_)
      , clone_ExpressaoAritmetica(p->u.regrarelacional2_.expressaoaritmetica_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraRelacional!\n");
    exit(1);
  }
}

ExpressaoLogica clone_ExpressaoLogica(ExpressaoLogica p)
{
  switch(p->kind)
  {
  case is_ExpressaoLogica_falso:
    return make_ExpressaoLogica_falso ();

  case is_ExpressaoLogica_verdadeiro:
    return make_ExpressaoLogica_verdadeiro ();

  case is_ExpressaoLogicaExpressaoRelacional:
    return make_ExpressaoLogicaExpressaoRelacional (clone_ExpressaoRelacional(p->u.expressaologicaexpressaorelacional_.expressaorelacional_));

  case is_ExpressaoLogica1:
    return make_ExpressaoLogica1 (clone_RegraLogico(p->u.expressaologica1_.regralogico_));

  case is_ExpressaoLogica2:
    return make_ExpressaoLogica2 (clone_RegraLogico(p->u.expressaologica2_.regralogico_));

  case is_ExpressaoLogica3:
    return make_ExpressaoLogica3
      ( clone_ExpressaoRelacional(p->u.expressaologica3_.expressaorelacional_)
      , clone_RegraLogico(p->u.expressaologica3_.regralogico_)
      );

  case is_ExpressaoLogica4:
    return make_ExpressaoLogica4
      ( clone_OperadorLogico(p->u.expressaologica4_.operadorlogico_)
      , clone_ExpressaoLogica(p->u.expressaologica4_.expressaologica_)
      );

  case is_ExpressaoLogica5:
    return make_ExpressaoLogica5
      ( clone_OperadorLogico(p->u.expressaologica5_.operadorlogico_)
      , clone_ExpressaoLogica(p->u.expressaologica5_.expressaologica_)
      , clone_RegraLogico(p->u.expressaologica5_.regralogico_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ExpressaoLogica!\n");
    exit(1);
  }
}

RegraLogico clone_RegraLogico(RegraLogico p)
{
  switch(p->kind)
  {
  case is_RegraLogico1:
    return make_RegraLogico1
      ( clone_OperadorLogico(p->u.regralogico1_.operadorlogico_)
      , clone_ExpressaoLogica(p->u.regralogico1_.expressaologica_)
      );

  case is_RegraLogico2:
    return make_RegraLogico2
      ( clone_OperadorLogico(p->u.regralogico2_.operadorlogico_)
      , clone_ExpressaoLogica(p->u.regralogico2_.expressaologica_)
      , clone_RegraLogico(p->u.regralogico2_.regralogico_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RegraLogico!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Entry(Entry p)
{
  switch(p->kind)
  {
  case is_L1:
    free(p->u.l1_.ident_);
    free_BlocoConstante(p->u.l1_.blococonstante_);
    free_BlocoTipo(p->u.l1_.blocotipo_);
    free_BlocoVar(p->u.l1_.blocovar_);
    free_BlocoComando(p->u.l1_.blococomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Entry!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoConstante(BlocoConstante p)
{
  switch(p->kind)
  {
  case is_BlocoConstante1:
    free_RegraBlocoConstante(p->u.blococonstante1_.regrablococonstante_);
    break;

  case is_BlocoConstante2:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoConstante!\n");
    exit(1);
  }
  free(p);
}

void free_RegraBlocoConstante(RegraBlocoConstante p)
{
  switch(p->kind)
  {
  case is_RegraBlocoConstante1:
    free(p->u.regrablococonstante1_.ident_);
    free_Valor(p->u.regrablococonstante1_.valor_);
    break;

  case is_RegraBlocoConstante2:
    free(p->u.regrablococonstante2_.ident_);
    free_Valor(p->u.regrablococonstante2_.valor_);
    free_RegraBlocoConstante(p->u.regrablococonstante2_.regrablococonstante_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraBlocoConstante!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoTipo(BlocoTipo p)
{
  switch(p->kind)
  {
  case is_BlocoTipo1:
    free_RegraBlocoTipo(p->u.blocotipo1_.regrablocotipo_);
    break;

  case is_BlocoTipo_:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoTipo!\n");
    exit(1);
  }
  free(p);
}

void free_RegraBlocoTipo(RegraBlocoTipo p)
{
  switch(p->kind)
  {
  case is_RegraBlocoTipo1:
    free(p->u.regrablocotipo1_.ident_);
    free_RegraTipo(p->u.regrablocotipo1_.regratipo_);
    break;

  case is_RegraBlocoTipo2:
    free(p->u.regrablocotipo2_.ident_);
    free_RegraTipo(p->u.regrablocotipo2_.regratipo_);
    free_RegraBlocoTipo(p->u.regrablocotipo2_.regrablocotipo_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraBlocoTipo!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoVar(BlocoVar p)
{
  switch(p->kind)
  {
  case is_BlocoVar1:
    free_RegraBlocoVar(p->u.blocovar1_.regrablocovar_);
    break;

  case is_BlocoVar2:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoVar!\n");
    exit(1);
  }
  free(p);
}

void free_RegraBlocoVar(RegraBlocoVar p)
{
  switch(p->kind)
  {
  case is_RegraBlocoVar1:
    free(p->u.regrablocovar1_.ident_);
    free_RegraTipo(p->u.regrablocovar1_.regratipo_);
    break;

  case is_RegraBlocoVar2:
    free(p->u.regrablocovar2_.ident_);
    free_RegraTipo(p->u.regrablocovar2_.regratipo_);
    free_RegraBlocoVar(p->u.regrablocovar2_.regrablocovar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraBlocoVar!\n");
    exit(1);
  }
  free(p);
}

void free_BlocoComando(BlocoComando p)
{
  switch(p->kind)
  {
  case is_BlocoComando1:
    free_RegraComando(p->u.blococomando1_.regracomando_);
    break;

  case is_BlocoComando2:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing BlocoComando!\n");
    exit(1);
  }
  free(p);
}

void free_RegraComando(RegraComando p)
{
  switch(p->kind)
  {
  case is_RegraComando1:
    free_Comando(p->u.regracomando1_.comando_);
    break;

  case is_RegraComando2:
    free_Comando(p->u.regracomando2_.comando_);
    free_RegraComando(p->u.regracomando2_.regracomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraComando!\n");
    exit(1);
  }
  free(p);
}

void free_Comando(Comando p)
{
  switch(p->kind)
  {
  case is_ComandoAtribuicao:
    free_Atribuicao(p->u.comandoatribuicao_.atribuicao_);
    break;

  case is_ComandoIf:
    free_If(p->u.comandoif_.if_);
    break;

  case is_ComandoWhile:
    free_While(p->u.comandowhile_.while_);
    break;

  case is_ComandoFor:
    free_For(p->u.comandofor_.for_);
    break;

  case is_ComandoGoto:
    free_Goto(p->u.comandogoto_.goto_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Comando!\n");
    exit(1);
  }
  free(p);
}

void free_Atribuicao(Atribuicao p)
{
  switch(p->kind)
  {
  case is_Atribuicao1:
    free(p->u.atribuicao1_.ident_);
    free_Valor(p->u.atribuicao1_.valor_);
    break;

  case is_Atribuicao2:
    free(p->u.atribuicao2_.ident_);
    free_SubEscrito(p->u.atribuicao2_.subescrito_);
    free_Valor(p->u.atribuicao2_.valor_);
    break;

  case is_Atribuicao3:
    free(p->u.atribuicao3_.ident_);
    free_Valor(p->u.atribuicao3_.valor_);
    break;

  case is_AtribuicaoAtribuicaoStruct:
    free_AtribuicaoStruct(p->u.atribuicaoatribuicaostruct_.atribuicaostruct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Atribuicao!\n");
    exit(1);
  }
  free(p);
}

void free_SubEscrito(SubEscrito p)
{
  switch(p->kind)
  {
  case is_SubEscritoIdent:
    free(p->u.subescritoident_.ident_);
    break;

  case is_SubEscritoInteger:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SubEscrito!\n");
    exit(1);
  }
  free(p);
}

void free_RegraTipo(RegraTipo p)
{
  switch(p->kind)
  {
  case is_RegraTipoTipoPrimitivo:
    free_TipoPrimitivo(p->u.regratipotipoprimitivo_.tipoprimitivo_);
    break;

  case is_RegraTipoTipoDerivado:
    free_TipoDerivado(p->u.regratipotipoderivado_.tipoderivado_);
    break;

  case is_RegraTipoIdent:
    free(p->u.regratipoident_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraTipo!\n");
    exit(1);
  }
  free(p);
}

void free_TipoPrimitivo(TipoPrimitivo p)
{
  switch(p->kind)
  {
  case is_TipoPrimitivo_int:
    break;

  case is_TipoPrimitivo_real:
    break;

  case is_TipoPrimitivo_char:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TipoPrimitivo!\n");
    exit(1);
  }
  free(p);
}

void free_Valor(Valor p)
{
  switch(p->kind)
  {
  case is_ValorInteger:
    break;

  case is_ValorDouble:
    break;

  case is_ValorChar:
    break;

  case is_ValorString:
    free(p->u.valorstring_.string_);
    break;

  case is_ValorExpressaoAritmetica:
    free_ExpressaoAritmetica(p->u.valorexpressaoaritmetica_.expressaoaritmetica_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Valor!\n");
    exit(1);
  }
  free(p);
}

void free_TipoDerivado(TipoDerivado p)
{
  switch(p->kind)
  {
  case is_TipoDerivadoPonteiro:
    free_Ponteiro(p->u.tipoderivadoponteiro_.ponteiro_);
    break;

  case is_TipoDerivadoVetor:
    free_Vetor(p->u.tipoderivadovetor_.vetor_);
    break;

  case is_TipoDerivadoStruct:
    free_Struct(p->u.tipoderivadostruct_.struct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TipoDerivado!\n");
    exit(1);
  }
  free(p);
}

void free_Ponteiro(Ponteiro p)
{
  switch(p->kind)
  {
  case is_Ponteiro1:
    free_TipoPrimitivo(p->u.ponteiro1_.tipoprimitivo_);
    break;

  case is_Ponteiro2:
    free_TipoDerivado(p->u.ponteiro2_.tipoderivado_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Ponteiro!\n");
    exit(1);
  }
  free(p);
}

void free_Vetor(Vetor p)
{
  switch(p->kind)
  {
  case is_L7:
    free_TipoPrimitivo(p->u.l7_.tipoprimitivo_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Vetor!\n");
    exit(1);
  }
  free(p);
}

void free_If(If p)
{
  switch(p->kind)
  {
  case is_If1:
    free_ExpressaoLogica(p->u.if1_.expressaologica_);
    free_BlocoComando(p->u.if1_.blococomando_);
    break;

  case is_If2:
    free_ExpressaoLogica(p->u.if2_.expressaologica_);
    free_BlocoComando(p->u.if2_.blococomando_1);
    free_BlocoComando(p->u.if2_.blococomando_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing If!\n");
    exit(1);
  }
  free(p);
}

void free_While(While p)
{
  switch(p->kind)
  {
  case is_L8:
    free_ExpressaoLogica(p->u.l8_.expressaologica_);
    free_BlocoComando(p->u.l8_.blococomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing While!\n");
    exit(1);
  }
  free(p);
}

void free_For(For p)
{
  switch(p->kind)
  {
  case is_For1:
    free_Atribuicao(p->u.for1_.atribuicao_);
    free_BlocoComando(p->u.for1_.blococomando_);
    break;

  case is_For2:
    free_Atribuicao(p->u.for2_.atribuicao_);
    free(p->u.for2_.ident_);
    free_BlocoComando(p->u.for2_.blococomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing For!\n");
    exit(1);
  }
  free(p);
}

void free_Goto(Goto p)
{
  switch(p->kind)
  {
  case is_L9:
    free(p->u.l9_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Goto!\n");
    exit(1);
  }
  free(p);
}

void free_Rotulo(Rotulo p)
{
  switch(p->kind)
  {
  case is_L10:
    free(p->u.l10_.ident_);
    free_RegraComando(p->u.l10_.regracomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Rotulo!\n");
    exit(1);
  }
  free(p);
}

void free_Struct(Struct p)
{
  switch(p->kind)
  {
  case is_L11:
    free_DefinicaoCampoStruct(p->u.l11_.definicaocampostruct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Struct!\n");
    exit(1);
  }
  free(p);
}

void free_DefinicaoCampoStruct(DefinicaoCampoStruct p)
{
  switch(p->kind)
  {
  case is_DefinicaoCampoStruct1:
    free(p->u.definicaocampostruct1_.ident_);
    free_RegraTipo(p->u.definicaocampostruct1_.regratipo_);
    break;

  case is_DefinicaoCampoStruct2:
    free(p->u.definicaocampostruct2_.ident_);
    free_RegraTipo(p->u.definicaocampostruct2_.regratipo_);
    free_DefinicaoCampoStruct(p->u.definicaocampostruct2_.definicaocampostruct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing DefinicaoCampoStruct!\n");
    exit(1);
  }
  free(p);
}

void free_AtribuicaoStruct(AtribuicaoStruct p)
{
  switch(p->kind)
  {
  case is_AtribuicaoStruct1:
    free(p->u.atribuicaostruct1_.ident_1);
    free(p->u.atribuicaostruct1_.ident_2);
    free_Valor(p->u.atribuicaostruct1_.valor_);
    break;

  case is_AtribuicaoStruct2:
    free(p->u.atribuicaostruct2_.ident_1);
    free(p->u.atribuicaostruct2_.ident_2);
    free_Valor(p->u.atribuicaostruct2_.valor_);
    free_AtribuicaoStruct(p->u.atribuicaostruct2_.atribuicaostruct_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing AtribuicaoStruct!\n");
    exit(1);
  }
  free(p);
}

void free_OperadorRelacional(OperadorRelacional p)
{
  switch(p->kind)
  {
  case is_OperadorRelacional1:
    break;

  case is_OperadorRelacional2:
    break;

  case is_OperadorRelacional3:
    break;

  case is_OperadorRelacional4:
    break;

  case is_OperadorRelacional5:
    break;

  case is_OperadorRelacional6:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OperadorRelacional!\n");
    exit(1);
  }
  free(p);
}

void free_OperadorLogico(OperadorLogico p)
{
  switch(p->kind)
  {
  case is_OperadorLogico1:
    break;

  case is_OperadorLogico2:
    break;

  case is_OperadorLogico3:
    break;

  case is_OperadorLogico4:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OperadorLogico!\n");
    exit(1);
  }
  free(p);
}

void free_OperadorAritmetico(OperadorAritmetico p)
{
  switch(p->kind)
  {
  case is_OperadorAritmetico1:
    break;

  case is_OperadorAritmetico2:
    break;

  case is_OperadorAritmetico3:
    break;

  case is_OperadorAritmetico4:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OperadorAritmetico!\n");
    exit(1);
  }
  free(p);
}

void free_Case(Case p)
{
  switch(p->kind)
  {
  case is_L12:
    free_Seletor(p->u.l12_.seletor_);
    free_RegraSeletor(p->u.l12_.regraseletor_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Case!\n");
    exit(1);
  }
  free(p);
}

void free_RegraSeletor(RegraSeletor p)
{
  switch(p->kind)
  {
  case is_RegraSeletor1:
    free_Seletor(p->u.regraseletor1_.seletor_);
    free_Comando(p->u.regraseletor1_.comando_);
    break;

  case is_RegraSeletor2:
    free_Seletor(p->u.regraseletor2_.seletor_);
    free_Comando(p->u.regraseletor2_.comando_);
    free_RegraSeletor(p->u.regraseletor2_.regraseletor_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraSeletor!\n");
    exit(1);
  }
  free(p);
}

void free_Seletor(Seletor p)
{
  switch(p->kind)
  {
  case is_SeletorInteger:
    break;

  case is_SeletorChar:
    break;

  case is_SeletorIdent:
    free(p->u.seletorident_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Seletor!\n");
    exit(1);
  }
  free(p);
}

void free_Funcao(Funcao p)
{
  switch(p->kind)
  {
  case is_L13:
    free(p->u.l13_.ident_);
    free_RegraBlocoVar(p->u.l13_.regrablocovar_);
    free_RegraTipo(p->u.l13_.regratipo_);
    free_BlocoVar(p->u.l13_.blocovar_);
    free_BlocoComando(p->u.l13_.blococomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Funcao!\n");
    exit(1);
  }
  free(p);
}

void free_Procedimento(Procedimento p)
{
  switch(p->kind)
  {
  case is_Procedimento1:
    free(p->u.procedimento1_.ident_);
    free_RegraBlocoVar(p->u.procedimento1_.regrablocovar_);
    free_BlocoVar(p->u.procedimento1_.blocovar_);
    free_BlocoComando(p->u.procedimento1_.blococomando_);
    break;

  case is_Procedimento2:
    free(p->u.procedimento2_.ident_);
    free_BlocoVar(p->u.procedimento2_.blocovar_);
    free_BlocoComando(p->u.procedimento2_.blococomando_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Procedimento!\n");
    exit(1);
  }
  free(p);
}

void free_ExpressaoAritmetica(ExpressaoAritmetica p)
{
  switch(p->kind)
  {
  case is_L14:
    free_Operando(p->u.l14_.operando_);
    free_RegraAritmetica(p->u.l14_.regraaritmetica_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ExpressaoAritmetica!\n");
    exit(1);
  }
  free(p);
}

void free_Operando(Operando p)
{
  switch(p->kind)
  {
  case is_OperandoInteger:
    break;

  case is_OperandoDouble:
    break;

  case is_OperandoIdent:
    free(p->u.operandoident_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Operando!\n");
    exit(1);
  }
  free(p);
}

void free_RegraAritmetica(RegraAritmetica p)
{
  switch(p->kind)
  {
  case is_RegraAritmetica1:
    free_OperadorAritmetico(p->u.regraaritmetica1_.operadoraritmetico_);
    free_Operando(p->u.regraaritmetica1_.operando_);
    break;

  case is_RegraAritmetica2:
    free_OperadorAritmetico(p->u.regraaritmetica2_.operadoraritmetico_);
    free_Operando(p->u.regraaritmetica2_.operando_);
    free_RegraAritmetica(p->u.regraaritmetica2_.regraaritmetica_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraAritmetica!\n");
    exit(1);
  }
  free(p);
}

void free_ExpressaoRelacional(ExpressaoRelacional p)
{
  switch(p->kind)
  {
  case is_ExpressaoRelacional1:
    free_Operando(p->u.expressaorelacional1_.operando_);
    free_RegraRelacional(p->u.expressaorelacional1_.regrarelacional_);
    break;

  case is_ExpressaoRelacional2:
    free_ExpressaoAritmetica(p->u.expressaorelacional2_.expressaoaritmetica_);
    free_RegraRelacional(p->u.expressaorelacional2_.regrarelacional_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ExpressaoRelacional!\n");
    exit(1);
  }
  free(p);
}

void free_RegraRelacional(RegraRelacional p)
{
  switch(p->kind)
  {
  case is_RegraRelacional1:
    free_OperadorRelacional(p->u.regrarelacional1_.operadorrelacional_);
    free_Operando(p->u.regrarelacional1_.operando_);
    break;

  case is_RegraRelacional2:
    free_OperadorRelacional(p->u.regrarelacional2_.operadorrelacional_);
    free_ExpressaoAritmetica(p->u.regrarelacional2_.expressaoaritmetica_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraRelacional!\n");
    exit(1);
  }
  free(p);
}

void free_ExpressaoLogica(ExpressaoLogica p)
{
  switch(p->kind)
  {
  case is_ExpressaoLogica_falso:
    break;

  case is_ExpressaoLogica_verdadeiro:
    break;

  case is_ExpressaoLogicaExpressaoRelacional:
    free_ExpressaoRelacional(p->u.expressaologicaexpressaorelacional_.expressaorelacional_);
    break;

  case is_ExpressaoLogica1:
    free_RegraLogico(p->u.expressaologica1_.regralogico_);
    break;

  case is_ExpressaoLogica2:
    free_RegraLogico(p->u.expressaologica2_.regralogico_);
    break;

  case is_ExpressaoLogica3:
    free_ExpressaoRelacional(p->u.expressaologica3_.expressaorelacional_);
    free_RegraLogico(p->u.expressaologica3_.regralogico_);
    break;

  case is_ExpressaoLogica4:
    free_OperadorLogico(p->u.expressaologica4_.operadorlogico_);
    free_ExpressaoLogica(p->u.expressaologica4_.expressaologica_);
    break;

  case is_ExpressaoLogica5:
    free_OperadorLogico(p->u.expressaologica5_.operadorlogico_);
    free_ExpressaoLogica(p->u.expressaologica5_.expressaologica_);
    free_RegraLogico(p->u.expressaologica5_.regralogico_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ExpressaoLogica!\n");
    exit(1);
  }
  free(p);
}

void free_RegraLogico(RegraLogico p)
{
  switch(p->kind)
  {
  case is_RegraLogico1:
    free_OperadorLogico(p->u.regralogico1_.operadorlogico_);
    free_ExpressaoLogica(p->u.regralogico1_.expressaologica_);
    break;

  case is_RegraLogico2:
    free_OperadorLogico(p->u.regralogico2_.operadorlogico_);
    free_ExpressaoLogica(p->u.regralogico2_.expressaologica_);
    free_RegraLogico(p->u.regralogico2_.regralogico_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RegraLogico!\n");
    exit(1);
  }
  free(p);
}

