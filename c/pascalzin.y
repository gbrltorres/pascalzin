/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the pascalzin_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE pascalzin__scan_string(const char *str, yyscan_t scanner);
extern void pascalzin__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void pascalzin_lex_destroy(yyscan_t scanner);
extern char* pascalzin_get_text(yyscan_t scanner);

extern yyscan_t pascalzin__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Entry entry_;
  BlocoDefinicoes blocodefinicoes_;
  BlocoFuncaoEProc blocofuncaoeproc_;
  BlocoConstante blococonstante_;
  RegraBlocoConstante regrablococonstante_;
  BlocoTipo blocotipo_;
  RegraBlocoTipo regrablocotipo_;
  BlocoVar blocovar_;
  RegraBlocoVar regrablocovar_;
  BlocoComando blococomando_;
  RegraComando regracomando_;
  Comando comando_;
  Atribuicao atribuicao_;
  SubEscrito subescrito_;
  RegraTipo regratipo_;
  TipoPrimitivo tipoprimitivo_;
  Valor valor_;
  TipoDerivado tipoderivado_;
  Ponteiro ponteiro_;
  Vetor vetor_;
  If if_;
  While while_;
  For for_;
  Goto goto_;
  Rotulo rotulo_;
  Struct struct_;
  DefinicaoCampoStruct definicaocampostruct_;
  AtribuicaoStruct atribuicaostruct_;
  OperadorRelacional operadorrelacional_;
  OperadorLogico operadorlogico_;
  OperadorAritmetico operadoraritmetico_;
  Case case_;
  RegraSeletor regraseletor_;
  Seletor seletor_;
  ChamadaFuncaoEProc chamadafuncaoeproc_;
  ListaIdent listaident_;
  Funcao funcao_;
  Procedimento procedimento_;
  ExpressaoAritmetica expressaoaritmetica_;
  Operando operando_;
  RegraAritmetica regraaritmetica_;
  ExpressaoRelacional expressaorelacional_;
  RegraRelacional regrarelacional_;
  ExpressaoLogica expressaologica_;
  RegraLogico regralogico_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, pascalzin_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANG             /* ! */
%token          _DAMP             /* && */
%token          _SYMB_19          /* &| */
%token          _LPAREN           /* ( */
%token          _RPAREN           /* ) */
%token          _STAR             /* * */
%token          _PLUS             /* + */
%token          _COMMA            /* , */
%token          _MINUS            /* - */
%token          _DOT              /* . */
%token          _DDOT             /* .. */
%token          _SLASH            /* / */
%token          _COLON            /* : */
%token          _COLONEQ          /* := */
%token          _SEMI             /* ; */
%token          _LT               /* < */
%token          _LDARROW          /* <= */
%token          _LTGT             /* <> */
%token          _EQ               /* = */
%token          _GT               /* > */
%token          _GTEQ             /* >= */
%token          _LBRACK           /* [ */
%token          _RBRACK           /* ] */
%token          _CARET            /* ^ */
%token          _KW_ate           /* ate */
%token          _KW_caso          /* caso */
%token          _KW_char          /* char */
%token          _KW_const         /* const */
%token          _KW_de            /* de */
%token          _KW_enquanto      /* enquanto */
%token          _KW_entao         /* entao */
%token          _KW_faca          /* faca */
%token          _KW_falso         /* falso */
%token          _KW_fim           /* fim */
%token          _KW_funcao        /* funcao */
%token          _KW_inicio        /* inicio */
%token          _KW_int           /* int */
%token          _KW_para          /* para */
%token          _KW_procedimento  /* procedimento */
%token          _KW_programa      /* programa */
%token          _KW_real          /* real */
%token          _KW_registro      /* registro */
%token          _KW_se            /* se */
%token          _KW_senao         /* senao */
%token          _KW_sovai         /* sovai */
%token          _KW_tipo          /* tipo */
%token          _KW_var           /* var */
%token          _KW_verdadeiro    /* verdadeiro */
%token          _KW_vetor         /* vetor */
%token          _DBAR             /* || */
%token<_string> _STRING_
%token<_char>   _CHAR_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <entry_> Entry
%type <blocodefinicoes_> BlocoDefinicoes
%type <blocofuncaoeproc_> BlocoFuncaoEProc
%type <blococonstante_> BlocoConstante
%type <regrablococonstante_> RegraBlocoConstante
%type <blocotipo_> BlocoTipo
%type <regrablocotipo_> RegraBlocoTipo
%type <blocovar_> BlocoVar
%type <regrablocovar_> RegraBlocoVar
%type <blococomando_> BlocoComando
%type <regracomando_> RegraComando
%type <comando_> Comando
%type <atribuicao_> Atribuicao
%type <subescrito_> SubEscrito
%type <regratipo_> RegraTipo
%type <tipoprimitivo_> TipoPrimitivo
%type <valor_> Valor
%type <tipoderivado_> TipoDerivado
%type <ponteiro_> Ponteiro
%type <vetor_> Vetor
%type <if_> If
%type <while_> While
%type <for_> For
%type <goto_> Goto
%type <rotulo_> Rotulo
%type <struct_> Struct
%type <definicaocampostruct_> DefinicaoCampoStruct
%type <atribuicaostruct_> AtribuicaoStruct
%type <operadorrelacional_> OperadorRelacional
%type <operadorlogico_> OperadorLogico
%type <operadoraritmetico_> OperadorAritmetico
%type <case_> Case
%type <regraseletor_> RegraSeletor
%type <seletor_> Seletor
%type <chamadafuncaoeproc_> ChamadaFuncaoEProc
%type <listaident_> ListaIdent
%type <funcao_> Funcao
%type <procedimento_> Procedimento
%type <expressaoaritmetica_> ExpressaoAritmetica
%type <operando_> Operando
%type <regraaritmetica_> RegraAritmetica
%type <expressaorelacional_> ExpressaoRelacional
%type <regrarelacional_> RegraRelacional
%type <expressaologica_> ExpressaoLogica
%type <regralogico_> RegraLogico

%start Entry

%%

Entry : _KW_programa _IDENT_ _SEMI BlocoDefinicoes BlocoComando _DOT { $$ = make_L1($2, $4, $5); result->entry_ = $$; }
;
BlocoDefinicoes : BlocoFuncaoEProc BlocoDefinicoes { $$ = make_BlocoDefinicoes1($1, $2); result->blocodefinicoes_ = $$; }
  | BlocoConstante BlocoDefinicoes { $$ = make_BlocoDefinicoes2($1, $2); result->blocodefinicoes_ = $$; }
  | BlocoTipo BlocoDefinicoes { $$ = make_BlocoDefinicoes3($1, $2); result->blocodefinicoes_ = $$; }
  | BlocoVar BlocoDefinicoes { $$ = make_BlocoDefinicoes4($1, $2); result->blocodefinicoes_ = $$; }
  | /* empty */ { $$ = make_BlocoDefinicoes_(); result->blocodefinicoes_ = $$; }
;
BlocoFuncaoEProc : Funcao { $$ = make_BlocoFuncaoEProcFuncao($1); result->blocofuncaoeproc_ = $$; }
  | Funcao BlocoFuncaoEProc { $$ = make_BlocoFuncaoEProc1($1, $2); result->blocofuncaoeproc_ = $$; }
  | Procedimento { $$ = make_BlocoFuncaoEProcProcedimento($1); result->blocofuncaoeproc_ = $$; }
  | Procedimento BlocoFuncaoEProc { $$ = make_BlocoFuncaoEProc2($1, $2); result->blocofuncaoeproc_ = $$; }
  | /* empty */ { $$ = make_BlocoFuncaoEProc_(); result->blocofuncaoeproc_ = $$; }
;
BlocoConstante : _KW_const RegraBlocoConstante { $$ = make_BlocoConstante1($2); result->blococonstante_ = $$; }
  | /* empty */ { $$ = make_BlocoConstante_(); result->blococonstante_ = $$; }
;
RegraBlocoConstante : _IDENT_ _EQ Valor _SEMI { $$ = make_RegraBlocoConstante1($1, $3); result->regrablococonstante_ = $$; }
  | _IDENT_ _EQ Valor _SEMI RegraBlocoConstante { $$ = make_RegraBlocoConstante2($1, $3, $5); result->regrablococonstante_ = $$; }
;
BlocoTipo : _KW_tipo RegraBlocoTipo { $$ = make_BlocoTipo1($2); result->blocotipo_ = $$; }
  | /* empty */ { $$ = make_BlocoTipo_(); result->blocotipo_ = $$; }
;
RegraBlocoTipo : _IDENT_ _EQ RegraTipo _SEMI { $$ = make_RegraBlocoTipo1($1, $3); result->regrablocotipo_ = $$; }
  | _IDENT_ _EQ RegraTipo _SEMI RegraBlocoTipo { $$ = make_RegraBlocoTipo2($1, $3, $5); result->regrablocotipo_ = $$; }
;
BlocoVar : _KW_var RegraBlocoVar { $$ = make_BlocoVar1($2); result->blocovar_ = $$; }
  | /* empty */ { $$ = make_BlocoVar_(); result->blocovar_ = $$; }
;
RegraBlocoVar : _IDENT_ _COLON RegraTipo _SEMI { $$ = make_RegraBlocoVar1($1, $3); result->regrablocovar_ = $$; }
  | _IDENT_ _COLON RegraTipo _SEMI RegraBlocoVar { $$ = make_RegraBlocoVar2($1, $3, $5); result->regrablocovar_ = $$; }
  | ListaIdent _COLON RegraTipo _SEMI { $$ = make_RegraBlocoVar3($1, $3); result->regrablocovar_ = $$; }
  | ListaIdent _COLON RegraTipo _SEMI RegraBlocoVar { $$ = make_RegraBlocoVar4($1, $3, $5); result->regrablocovar_ = $$; }
;
BlocoComando : _KW_inicio RegraComando _KW_fim { $$ = make_BlocoComando1($2); result->blococomando_ = $$; }
  | /* empty */ { $$ = make_BlocoComando_(); result->blococomando_ = $$; }
;
RegraComando : Comando _SEMI { $$ = make_RegraComando1($1); result->regracomando_ = $$; }
  | Comando _SEMI RegraComando { $$ = make_RegraComando2($1, $3); result->regracomando_ = $$; }
;
Comando : Atribuicao { $$ = make_ComandoAtribuicao($1); result->comando_ = $$; }
  | If { $$ = make_ComandoIf($1); result->comando_ = $$; }
  | While { $$ = make_ComandoWhile($1); result->comando_ = $$; }
  | For { $$ = make_ComandoFor($1); result->comando_ = $$; }
  | Goto { $$ = make_ComandoGoto($1); result->comando_ = $$; }
  | Case { $$ = make_ComandoCase($1); result->comando_ = $$; }
  | ChamadaFuncaoEProc { $$ = make_ComandoChamadaFuncaoEProc($1); result->comando_ = $$; }
;
Atribuicao : _IDENT_ _COLONEQ Valor { $$ = make_Atribuicao1($1, $3); result->atribuicao_ = $$; }
  | _IDENT_ _COLONEQ _IDENT_ { $$ = make_Atribuicao2($1, $3); result->atribuicao_ = $$; }
  | _IDENT_ _LBRACK SubEscrito _RBRACK _COLONEQ Valor { $$ = make_Atribuicao3($1, $3, $6); result->atribuicao_ = $$; }
  | _IDENT_ _CARET _COLONEQ Valor { $$ = make_Atribuicao4($1, $4); result->atribuicao_ = $$; }
  | AtribuicaoStruct { $$ = make_AtribuicaoAtribuicaoStruct($1); result->atribuicao_ = $$; }
  | _IDENT_ _COLONEQ ChamadaFuncaoEProc { $$ = make_Atribuicao5($1, $3); result->atribuicao_ = $$; }
;
SubEscrito : _IDENT_ { $$ = make_SubEscritoIdent($1); result->subescrito_ = $$; }
  | _INTEGER_ { $$ = make_SubEscritoInteger($1); result->subescrito_ = $$; }
;
RegraTipo : TipoPrimitivo { $$ = make_RegraTipoTipoPrimitivo($1); result->regratipo_ = $$; }
  | TipoDerivado { $$ = make_RegraTipoTipoDerivado($1); result->regratipo_ = $$; }
  | _IDENT_ { $$ = make_RegraTipoIdent($1); result->regratipo_ = $$; }
;
TipoPrimitivo : _KW_int { $$ = make_TipoPrimitivo_int(); result->tipoprimitivo_ = $$; }
  | _KW_real { $$ = make_TipoPrimitivo_real(); result->tipoprimitivo_ = $$; }
  | _KW_char { $$ = make_TipoPrimitivo_char(); result->tipoprimitivo_ = $$; }
;
Valor : _INTEGER_ { $$ = make_ValorInteger($1); result->valor_ = $$; }
  | _DOUBLE_ { $$ = make_ValorDouble($1); result->valor_ = $$; }
  | _CHAR_ { $$ = make_ValorChar($1); result->valor_ = $$; }
  | _STRING_ { $$ = make_ValorString($1); result->valor_ = $$; }
  | ExpressaoAritmetica { $$ = make_ValorExpressaoAritmetica($1); result->valor_ = $$; }
;
TipoDerivado : Ponteiro { $$ = make_TipoDerivadoPonteiro($1); result->tipoderivado_ = $$; }
  | Vetor { $$ = make_TipoDerivadoVetor($1); result->tipoderivado_ = $$; }
  | Struct { $$ = make_TipoDerivadoStruct($1); result->tipoderivado_ = $$; }
;
Ponteiro : _CARET TipoPrimitivo { $$ = make_Ponteiro1($2); result->ponteiro_ = $$; }
  | _CARET TipoDerivado { $$ = make_Ponteiro2($2); result->ponteiro_ = $$; }
;
Vetor : _KW_vetor _LBRACK _INTEGER_ _DDOT _INTEGER_ _RBRACK _KW_de TipoPrimitivo { $$ = make_L7($3, $5, $8); result->vetor_ = $$; }
;
If : _KW_se _LPAREN ExpressaoLogica _RPAREN _KW_entao BlocoComando { $$ = make_If1($3, $6); result->if_ = $$; }
  | _KW_se _LPAREN ExpressaoLogica _RPAREN _KW_entao BlocoComando _KW_senao BlocoComando { $$ = make_If2($3, $6, $8); result->if_ = $$; }
;
While : _KW_enquanto _LPAREN ExpressaoLogica _RPAREN _KW_faca BlocoComando { $$ = make_L8($3, $6); result->while_ = $$; }
;
For : _KW_para Atribuicao _KW_ate _INTEGER_ _KW_faca BlocoComando { $$ = make_For1($2, $4, $6); result->for_ = $$; }
  | _KW_para Atribuicao _KW_ate _IDENT_ _KW_faca BlocoComando { $$ = make_For2($2, $4, $6); result->for_ = $$; }
;
Goto : _KW_sovai _IDENT_ { $$ = make_L9($2); result->goto_ = $$; }
;
Rotulo : _IDENT_ _COLON RegraComando { $$ = make_L10($1, $3); result->rotulo_ = $$; }
;
Struct : _KW_registro DefinicaoCampoStruct _KW_fim { $$ = make_L11($2); result->struct_ = $$; }
;
DefinicaoCampoStruct : _IDENT_ _COLON RegraTipo _SEMI { $$ = make_DefinicaoCampoStruct1($1, $3); result->definicaocampostruct_ = $$; }
  | _IDENT_ _COLON RegraTipo _SEMI DefinicaoCampoStruct { $$ = make_DefinicaoCampoStruct2($1, $3, $5); result->definicaocampostruct_ = $$; }
;
AtribuicaoStruct : _IDENT_ _DOT _IDENT_ _COLONEQ Valor { $$ = make_AtribuicaoStruct1($1, $3, $5); result->atribuicaostruct_ = $$; }
  | _IDENT_ _DOT _IDENT_ _COLONEQ Valor AtribuicaoStruct { $$ = make_AtribuicaoStruct2($1, $3, $5, $6); result->atribuicaostruct_ = $$; }
;
OperadorRelacional : _GT { $$ = make_OperadorRelacional1(); result->operadorrelacional_ = $$; }
  | _LT { $$ = make_OperadorRelacional2(); result->operadorrelacional_ = $$; }
  | _LTGT { $$ = make_OperadorRelacional3(); result->operadorrelacional_ = $$; }
  | _GTEQ { $$ = make_OperadorRelacional4(); result->operadorrelacional_ = $$; }
  | _LDARROW { $$ = make_OperadorRelacional5(); result->operadorrelacional_ = $$; }
  | _EQ { $$ = make_OperadorRelacional6(); result->operadorrelacional_ = $$; }
;
OperadorLogico : _BANG { $$ = make_OperadorLogico1(); result->operadorlogico_ = $$; }
  | _DAMP { $$ = make_OperadorLogico2(); result->operadorlogico_ = $$; }
  | _DBAR { $$ = make_OperadorLogico3(); result->operadorlogico_ = $$; }
  | _SYMB_19 { $$ = make_OperadorLogico4(); result->operadorlogico_ = $$; }
;
OperadorAritmetico : _PLUS { $$ = make_OperadorAritmetico1(); result->operadoraritmetico_ = $$; }
  | _MINUS { $$ = make_OperadorAritmetico2(); result->operadoraritmetico_ = $$; }
  | _STAR { $$ = make_OperadorAritmetico3(); result->operadoraritmetico_ = $$; }
  | _SLASH { $$ = make_OperadorAritmetico4(); result->operadoraritmetico_ = $$; }
;
Case : _KW_caso _LPAREN Seletor _RPAREN _KW_de RegraSeletor _KW_fim { $$ = make_L12($3, $6); result->case_ = $$; }
;
RegraSeletor : Seletor _COLON Comando _SEMI { $$ = make_RegraSeletor1($1, $3); result->regraseletor_ = $$; }
  | Seletor _COLON Comando _SEMI RegraSeletor { $$ = make_RegraSeletor2($1, $3, $5); result->regraseletor_ = $$; }
;
Seletor : _INTEGER_ { $$ = make_SeletorInteger($1); result->seletor_ = $$; }
  | _CHAR_ { $$ = make_SeletorChar($1); result->seletor_ = $$; }
  | _IDENT_ { $$ = make_SeletorIdent($1); result->seletor_ = $$; }
;
ChamadaFuncaoEProc : _IDENT_ _LPAREN ListaIdent _RPAREN { $$ = make_L33($1, $3); result->chamadafuncaoeproc_ = $$; }
;
ListaIdent : _IDENT_ { $$ = make_ListaIdentIdent($1); result->listaident_ = $$; }
  | _IDENT_ _COMMA ListaIdent { $$ = make_ListaIdent1($1, $3); result->listaident_ = $$; }
;
Funcao : _KW_funcao _IDENT_ _LPAREN RegraBlocoVar _RPAREN _COLON RegraTipo BlocoVar BlocoComando _SEMI { $$ = make_L13($2, $4, $7, $8, $9); result->funcao_ = $$; }
;
Procedimento : _KW_procedimento _IDENT_ _LPAREN RegraBlocoVar _RPAREN BlocoVar BlocoComando { $$ = make_Procedimento1($2, $4, $6, $7); result->procedimento_ = $$; }
  | _KW_procedimento _IDENT_ _LPAREN _RPAREN BlocoVar BlocoComando { $$ = make_Procedimento2($2, $5, $6); result->procedimento_ = $$; }
;
ExpressaoAritmetica : Operando RegraAritmetica { $$ = make_L14($1, $2); result->expressaoaritmetica_ = $$; }
;
Operando : _INTEGER_ { $$ = make_OperandoInteger($1); result->operando_ = $$; }
  | _DOUBLE_ { $$ = make_OperandoDouble($1); result->operando_ = $$; }
  | _IDENT_ { $$ = make_OperandoIdent($1); result->operando_ = $$; }
;
RegraAritmetica : OperadorAritmetico Operando { $$ = make_RegraAritmetica1($1, $2); result->regraaritmetica_ = $$; }
  | OperadorAritmetico Operando RegraAritmetica { $$ = make_RegraAritmetica2($1, $2, $3); result->regraaritmetica_ = $$; }
;
ExpressaoRelacional : Operando RegraRelacional { $$ = make_ExpressaoRelacional1($1, $2); result->expressaorelacional_ = $$; }
  | ExpressaoAritmetica RegraRelacional { $$ = make_ExpressaoRelacional2($1, $2); result->expressaorelacional_ = $$; }
;
RegraRelacional : OperadorRelacional Operando { $$ = make_RegraRelacional1($1, $2); result->regrarelacional_ = $$; }
  | OperadorRelacional ExpressaoAritmetica { $$ = make_RegraRelacional2($1, $2); result->regrarelacional_ = $$; }
;
ExpressaoLogica : _KW_falso { $$ = make_ExpressaoLogica_falso(); result->expressaologica_ = $$; }
  | _KW_falso RegraLogico { $$ = make_ExpressaoLogica1($2); result->expressaologica_ = $$; }
  | _KW_verdadeiro { $$ = make_ExpressaoLogica_verdadeiro(); result->expressaologica_ = $$; }
  | _KW_verdadeiro RegraLogico { $$ = make_ExpressaoLogica2($2); result->expressaologica_ = $$; }
  | ExpressaoRelacional { $$ = make_ExpressaoLogicaExpressaoRelacional($1); result->expressaologica_ = $$; }
  | ExpressaoRelacional RegraLogico { $$ = make_ExpressaoLogica3($1, $2); result->expressaologica_ = $$; }
  | OperadorLogico ExpressaoLogica { $$ = make_ExpressaoLogica4($1, $2); result->expressaologica_ = $$; }
  | OperadorLogico ExpressaoLogica RegraLogico { $$ = make_ExpressaoLogica5($1, $2, $3); result->expressaologica_ = $$; }
  | OperadorLogico _IDENT_ { $$ = make_ExpressaoLogica6($1, $2); result->expressaologica_ = $$; }
  | OperadorLogico _IDENT_ RegraLogico { $$ = make_ExpressaoLogica7($1, $2, $3); result->expressaologica_ = $$; }
;
RegraLogico : OperadorLogico ExpressaoLogica { $$ = make_RegraLogico1($1, $2); result->regralogico_ = $$; }
  | OperadorLogico ExpressaoLogica RegraLogico { $$ = make_RegraLogico2($1, $2, $3); result->regralogico_ = $$; }
;

%%


/* Entrypoint: parse Entry from file. */
Entry pEntry(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.entry_;
  }
}

/* Entrypoint: parse Entry from string. */
Entry psEntry(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.entry_;
  }
}

/* Entrypoint: parse BlocoDefinicoes from file. */
BlocoDefinicoes pBlocoDefinicoes(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocodefinicoes_;
  }
}

/* Entrypoint: parse BlocoDefinicoes from string. */
BlocoDefinicoes psBlocoDefinicoes(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocodefinicoes_;
  }
}

/* Entrypoint: parse BlocoFuncaoEProc from file. */
BlocoFuncaoEProc pBlocoFuncaoEProc(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocofuncaoeproc_;
  }
}

/* Entrypoint: parse BlocoFuncaoEProc from string. */
BlocoFuncaoEProc psBlocoFuncaoEProc(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocofuncaoeproc_;
  }
}

/* Entrypoint: parse BlocoConstante from file. */
BlocoConstante pBlocoConstante(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococonstante_;
  }
}

/* Entrypoint: parse BlocoConstante from string. */
BlocoConstante psBlocoConstante(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococonstante_;
  }
}

/* Entrypoint: parse RegraBlocoConstante from file. */
RegraBlocoConstante pRegraBlocoConstante(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablococonstante_;
  }
}

/* Entrypoint: parse RegraBlocoConstante from string. */
RegraBlocoConstante psRegraBlocoConstante(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablococonstante_;
  }
}

/* Entrypoint: parse BlocoTipo from file. */
BlocoTipo pBlocoTipo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocotipo_;
  }
}

/* Entrypoint: parse BlocoTipo from string. */
BlocoTipo psBlocoTipo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocotipo_;
  }
}

/* Entrypoint: parse RegraBlocoTipo from file. */
RegraBlocoTipo pRegraBlocoTipo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocotipo_;
  }
}

/* Entrypoint: parse RegraBlocoTipo from string. */
RegraBlocoTipo psRegraBlocoTipo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocotipo_;
  }
}

/* Entrypoint: parse BlocoVar from file. */
BlocoVar pBlocoVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocovar_;
  }
}

/* Entrypoint: parse BlocoVar from string. */
BlocoVar psBlocoVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blocovar_;
  }
}

/* Entrypoint: parse RegraBlocoVar from file. */
RegraBlocoVar pRegraBlocoVar(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocovar_;
  }
}

/* Entrypoint: parse RegraBlocoVar from string. */
RegraBlocoVar psRegraBlocoVar(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrablocovar_;
  }
}

/* Entrypoint: parse BlocoComando from file. */
BlocoComando pBlocoComando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococomando_;
  }
}

/* Entrypoint: parse BlocoComando from string. */
BlocoComando psBlocoComando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.blococomando_;
  }
}

/* Entrypoint: parse RegraComando from file. */
RegraComando pRegraComando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regracomando_;
  }
}

/* Entrypoint: parse RegraComando from string. */
RegraComando psRegraComando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regracomando_;
  }
}

/* Entrypoint: parse Comando from file. */
Comando pComando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.comando_;
  }
}

/* Entrypoint: parse Comando from string. */
Comando psComando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.comando_;
  }
}

/* Entrypoint: parse Atribuicao from file. */
Atribuicao pAtribuicao(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicao_;
  }
}

/* Entrypoint: parse Atribuicao from string. */
Atribuicao psAtribuicao(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicao_;
  }
}

/* Entrypoint: parse SubEscrito from file. */
SubEscrito pSubEscrito(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.subescrito_;
  }
}

/* Entrypoint: parse SubEscrito from string. */
SubEscrito psSubEscrito(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.subescrito_;
  }
}

/* Entrypoint: parse RegraTipo from file. */
RegraTipo pRegraTipo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regratipo_;
  }
}

/* Entrypoint: parse RegraTipo from string. */
RegraTipo psRegraTipo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regratipo_;
  }
}

/* Entrypoint: parse TipoPrimitivo from file. */
TipoPrimitivo pTipoPrimitivo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoprimitivo_;
  }
}

/* Entrypoint: parse TipoPrimitivo from string. */
TipoPrimitivo psTipoPrimitivo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoprimitivo_;
  }
}

/* Entrypoint: parse Valor from file. */
Valor pValor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valor_;
  }
}

/* Entrypoint: parse Valor from string. */
Valor psValor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valor_;
  }
}

/* Entrypoint: parse TipoDerivado from file. */
TipoDerivado pTipoDerivado(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoderivado_;
  }
}

/* Entrypoint: parse TipoDerivado from string. */
TipoDerivado psTipoDerivado(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.tipoderivado_;
  }
}

/* Entrypoint: parse Ponteiro from file. */
Ponteiro pPonteiro(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ponteiro_;
  }
}

/* Entrypoint: parse Ponteiro from string. */
Ponteiro psPonteiro(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ponteiro_;
  }
}

/* Entrypoint: parse Vetor from file. */
Vetor pVetor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vetor_;
  }
}

/* Entrypoint: parse Vetor from string. */
Vetor psVetor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vetor_;
  }
}

/* Entrypoint: parse If from file. */
If pIf(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse If from string. */
If psIf(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.if_;
  }
}

/* Entrypoint: parse While from file. */
While pWhile(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse While from string. */
While psWhile(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.while_;
  }
}

/* Entrypoint: parse For from file. */
For pFor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse For from string. */
For psFor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.for_;
  }
}

/* Entrypoint: parse Goto from file. */
Goto pGoto(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse Goto from string. */
Goto psGoto(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse Rotulo from file. */
Rotulo pRotulo(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rotulo_;
  }
}

/* Entrypoint: parse Rotulo from string. */
Rotulo psRotulo(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.rotulo_;
  }
}

/* Entrypoint: parse Struct from file. */
Struct pStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse Struct from string. */
Struct psStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse DefinicaoCampoStruct from file. */
DefinicaoCampoStruct pDefinicaoCampoStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.definicaocampostruct_;
  }
}

/* Entrypoint: parse DefinicaoCampoStruct from string. */
DefinicaoCampoStruct psDefinicaoCampoStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.definicaocampostruct_;
  }
}

/* Entrypoint: parse AtribuicaoStruct from file. */
AtribuicaoStruct pAtribuicaoStruct(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaostruct_;
  }
}

/* Entrypoint: parse AtribuicaoStruct from string. */
AtribuicaoStruct psAtribuicaoStruct(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atribuicaostruct_;
  }
}

/* Entrypoint: parse OperadorRelacional from file. */
OperadorRelacional pOperadorRelacional(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorrelacional_;
  }
}

/* Entrypoint: parse OperadorRelacional from string. */
OperadorRelacional psOperadorRelacional(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorrelacional_;
  }
}

/* Entrypoint: parse OperadorLogico from file. */
OperadorLogico pOperadorLogico(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorlogico_;
  }
}

/* Entrypoint: parse OperadorLogico from string. */
OperadorLogico psOperadorLogico(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadorlogico_;
  }
}

/* Entrypoint: parse OperadorAritmetico from file. */
OperadorAritmetico pOperadorAritmetico(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadoraritmetico_;
  }
}

/* Entrypoint: parse OperadorAritmetico from string. */
OperadorAritmetico psOperadorAritmetico(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operadoraritmetico_;
  }
}

/* Entrypoint: parse Case from file. */
Case pCase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.case_;
  }
}

/* Entrypoint: parse Case from string. */
Case psCase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.case_;
  }
}

/* Entrypoint: parse RegraSeletor from file. */
RegraSeletor pRegraSeletor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraseletor_;
  }
}

/* Entrypoint: parse RegraSeletor from string. */
RegraSeletor psRegraSeletor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraseletor_;
  }
}

/* Entrypoint: parse Seletor from file. */
Seletor pSeletor(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.seletor_;
  }
}

/* Entrypoint: parse Seletor from string. */
Seletor psSeletor(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.seletor_;
  }
}

/* Entrypoint: parse ChamadaFuncaoEProc from file. */
ChamadaFuncaoEProc pChamadaFuncaoEProc(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.chamadafuncaoeproc_;
  }
}

/* Entrypoint: parse ChamadaFuncaoEProc from string. */
ChamadaFuncaoEProc psChamadaFuncaoEProc(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.chamadafuncaoeproc_;
  }
}

/* Entrypoint: parse ListaIdent from file. */
ListaIdent pListaIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listaident_;
  }
}

/* Entrypoint: parse ListaIdent from string. */
ListaIdent psListaIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listaident_;
  }
}

/* Entrypoint: parse Funcao from file. */
Funcao pFuncao(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcao_;
  }
}

/* Entrypoint: parse Funcao from string. */
Funcao psFuncao(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.funcao_;
  }
}

/* Entrypoint: parse Procedimento from file. */
Procedimento pProcedimento(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedimento_;
  }
}

/* Entrypoint: parse Procedimento from string. */
Procedimento psProcedimento(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.procedimento_;
  }
}

/* Entrypoint: parse ExpressaoAritmetica from file. */
ExpressaoAritmetica pExpressaoAritmetica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaoaritmetica_;
  }
}

/* Entrypoint: parse ExpressaoAritmetica from string. */
ExpressaoAritmetica psExpressaoAritmetica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaoaritmetica_;
  }
}

/* Entrypoint: parse Operando from file. */
Operando pOperando(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operando_;
  }
}

/* Entrypoint: parse Operando from string. */
Operando psOperando(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operando_;
  }
}

/* Entrypoint: parse RegraAritmetica from file. */
RegraAritmetica pRegraAritmetica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraaritmetica_;
  }
}

/* Entrypoint: parse RegraAritmetica from string. */
RegraAritmetica psRegraAritmetica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regraaritmetica_;
  }
}

/* Entrypoint: parse ExpressaoRelacional from file. */
ExpressaoRelacional pExpressaoRelacional(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaorelacional_;
  }
}

/* Entrypoint: parse ExpressaoRelacional from string. */
ExpressaoRelacional psExpressaoRelacional(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaorelacional_;
  }
}

/* Entrypoint: parse RegraRelacional from file. */
RegraRelacional pRegraRelacional(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrarelacional_;
  }
}

/* Entrypoint: parse RegraRelacional from string. */
RegraRelacional psRegraRelacional(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regrarelacional_;
  }
}

/* Entrypoint: parse ExpressaoLogica from file. */
ExpressaoLogica pExpressaoLogica(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaologica_;
  }
}

/* Entrypoint: parse ExpressaoLogica from string. */
ExpressaoLogica psExpressaoLogica(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expressaologica_;
  }
}

/* Entrypoint: parse RegraLogico from file. */
RegraLogico pRegraLogico(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regralogico_;
  }
}

/* Entrypoint: parse RegraLogico from string. */
RegraLogico psRegraLogico(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pascalzin__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pascalzin__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pascalzin__delete_buffer(buf, scanner);
  pascalzin_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.regralogico_;
  }
}



